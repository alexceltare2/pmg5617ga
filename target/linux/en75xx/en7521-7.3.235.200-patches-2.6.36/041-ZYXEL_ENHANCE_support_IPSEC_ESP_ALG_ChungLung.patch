Index: linux-2.6.36/include/linux/rcupdate.h
===================================================================
--- linux-2.6.36.orig/include/linux/rcupdate.h	2010-10-21 04:30:22.000000000 +0800
+++ linux-2.6.36/include/linux/rcupdate.h	2017-04-27 17:01:39.812819238 +0800
@@ -485,6 +485,41 @@
 		(p) = (v); \
 	})
 
+/**
+ * RCU_INIT_POINTER() - initialize an RCU protected pointer
+ *
+ * Initialize an RCU-protected pointer in special cases where readers
+ * do not need ordering constraints on the CPU or the compiler.  These
+ * special cases are:
+ *
+ * 1.	This use of RCU_INIT_POINTER() is NULLing out the pointer -or-
+ * 2.	The caller has taken whatever steps are required to prevent
+ *	RCU readers from concurrently accessing this pointer -or-
+ * 3.	The referenced data structure has already been exposed to
+ *	readers either at compile time or via rcu_assign_pointer() -and-
+ *	a.	You have not made -any- reader-visible changes to
+ *		this structure since then -or-
+ *	b.	It is OK for readers accessing this structure from its
+ *		new location to see the old state of the structure.  (For
+ *		example, the changes were to statistical counters or to
+ *		other state where exact synchronization is not required.)
+ *
+ * Failure to follow these rules governing use of RCU_INIT_POINTER() will
+ * result in impossible-to-diagnose memory corruption.  As in the structures
+ * will look OK in crash dumps, but any concurrent RCU readers might
+ * see pre-initialized values of the referenced data structure.  So
+ * please be very careful how you use RCU_INIT_POINTER()!!!
+ *
+ * If you are creating an RCU-protected linked structure that is accessed
+ * by a single external-to-structure RCU-protected pointer, then you may
+ * use RCU_INIT_POINTER() to initialize the internal RCU-protected
+ * pointers, but you must use rcu_assign_pointer() to initialize the
+ * external-to-structure pointer -after- you have completely initialized
+ * the reader-accessible portions of the linked structure.
+ */
+#define RCU_INIT_POINTER(p, v) \
+		p = (typeof(*v) __force __rcu *)(v)
+
 /* Infrastructure to implement the synchronize_() primitives. */
 
 struct rcu_synchronize {
Index: linux-2.6.36/include/net/netfilter/nf_conntrack.h
===================================================================
--- linux-2.6.36.orig/include/net/netfilter/nf_conntrack.h	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/include/net/netfilter/nf_conntrack.h	2017-04-27 17:01:39.812819238 +0800
@@ -23,7 +23,10 @@
 #include <linux/netfilter/nf_conntrack_dccp.h>
 #include <linux/netfilter/nf_conntrack_sctp.h>
 #include <linux/netfilter/nf_conntrack_proto_gre.h>
+#if (defined(CONFIG_NF_CONNTRACK_IPSEC) || defined(CONFIG_NF_CONNTRACK_IPSEC_MODULE))
+#include <linux/netfilter/nf_conntrack_ipsec.h>
 #include <linux/netfilter/nf_conntrack_proto_esp.h>
+#endif
 #include <net/netfilter/ipv6/nf_conntrack_icmpv6.h>
 
 #include <net/netfilter/nf_conntrack_tuple.h>
@@ -35,7 +38,9 @@
 	struct ip_ct_sctp sctp;
 	struct ip_ct_tcp tcp;
 	struct nf_ct_gre gre;
+#if (defined(CONFIG_NF_CT_PROTO_ESP) || defined(CONFIG_NF_CT_PROTO_ESP_MODULE))
 	struct nf_ct_esp esp;
+#endif
 };
 
 union nf_conntrack_expect_proto {
@@ -48,7 +53,6 @@
 #include <linux/netfilter/nf_conntrack_h323.h>
 #include <linux/netfilter/nf_conntrack_sane.h>
 #include <linux/netfilter/nf_conntrack_sip.h>
-#include <linux/netfilter/nf_conntrack_ipsec.h>
 
 /* per conntrack: application helper private data */
 union nf_conntrack_help {
@@ -58,7 +62,9 @@
 	struct nf_ct_h323_master ct_h323_info;
 	struct nf_ct_sane_master ct_sane_info;
 	struct nf_ct_sip_master ct_sip_info;
+#if (defined(CONFIG_NF_CONNTRACK_IPSEC) || defined(CONFIG_NF_CONNTRACK_IPSEC_MODULE))
 	struct nf_ct_ipsec_master ct_ipsec_info;
+#endif
 };
 
 #include <linux/types.h>
Index: linux-2.6.36/include/net/netfilter/nf_conntrack_l4proto.h
===================================================================
--- linux-2.6.36.orig/include/net/netfilter/nf_conntrack_l4proto.h	2010-10-21 04:30:22.000000000 +0800
+++ linux-2.6.36/include/net/netfilter/nf_conntrack_l4proto.h	2017-04-27 17:01:39.832819238 +0800
@@ -60,6 +60,9 @@
 	/* Print out the private part of the conntrack. */
 	int (*print_conntrack)(struct seq_file *s, struct nf_conn *);
 
+	/* Return the array of timeouts for this protocol. */
+	unsigned int *(*get_timeouts)(struct net *net);
+
 	/* convert protoinfo to nfnetink attributes */
 	int (*to_nlattr)(struct sk_buff *skb, struct nlattr *nla,
 			 struct nf_conn *ct);
Index: linux-2.6.36/include/net/netfilter/nf_conntrack_tuple.h
===================================================================
--- linux-2.6.36.orig/include/net/netfilter/nf_conntrack_tuple.h	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/include/net/netfilter/nf_conntrack_tuple.h	2017-04-27 17:01:39.832819238 +0800
@@ -90,9 +90,11 @@
 			struct {
 				__be16 key;
 			} gre;
+#if (defined(CONFIG_NF_CT_PROTO_ESP) || defined(CONFIG_NF_CT_PROTO_ESP_MODULE))
 			struct {
 				__be16 spi;
 			} esp;
+#endif
 		} u;
 
 		/* The protocol. */
Index: linux-2.6.36/net/ipv4/netfilter/Kconfig
===================================================================
--- linux-2.6.36.orig/net/ipv4/netfilter/Kconfig	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/ipv4/netfilter/Kconfig	2017-04-27 17:01:39.832819238 +0800
@@ -236,11 +236,6 @@
 	tristate
 	depends on NF_NAT && NF_CT_PROTO_GRE
 
-config NF_NAT_PROTO_ESP
-	tristate
-	depends on NF_NAT && NF_CT_PROTO_ESP
-	default NF_NAT && NF_CT_PROTO_ESP
-
 config NF_NAT_PROTO_UDPLITE
 	tristate
 	depends on NF_NAT && NF_CT_PROTO_UDPLITE
@@ -252,6 +247,11 @@
 	depends on NF_NAT && NF_CT_PROTO_SCTP
 	select LIBCRC32C
 
+config NF_NAT_PROTO_ESP
+	tristate
+	depends on NF_NAT && NF_CT_PROTO_ESP
+	default NF_NAT && NF_CT_PROTO_ESP
+
 config NF_NAT_FTP
 	tristate
 	depends on NF_CONNTRACK && NF_NAT
Index: linux-2.6.36/net/ipv4/netfilter/Makefile
===================================================================
--- linux-2.6.36.orig/net/ipv4/netfilter/Makefile	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/ipv4/netfilter/Makefile	2017-04-27 17:01:39.832819238 +0800
@@ -28,18 +28,18 @@
 obj-$(CONFIG_NF_NAT_IRC) += nf_nat_irc.o
 obj-$(CONFIG_NF_NAT_PPTP) += nf_nat_pptp.o
 obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
+obj-$(CONFIG_NF_NAT_IPSEC) += nf_nat_ipsec.o
 obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
 obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
 obj-$(CONFIG_NF_NAT_RTSP) += nf_nat_rtsp.o
-obj-$(CONFIG_NF_NAT_IPSEC) += nf_nat_ipsec.o
 obj-$(CONFIG_NF_NAT_PT) += nf_nat_pt.o
 
 # NAT protocols (nf_nat)
 obj-$(CONFIG_NF_NAT_PROTO_DCCP) += nf_nat_proto_dccp.o
 obj-$(CONFIG_NF_NAT_PROTO_GRE) += nf_nat_proto_gre.o
-obj-$(CONFIG_NF_NAT_PROTO_ESP) += nf_nat_proto_esp.o
 obj-$(CONFIG_NF_NAT_PROTO_UDPLITE) += nf_nat_proto_udplite.o
 obj-$(CONFIG_NF_NAT_PROTO_SCTP) += nf_nat_proto_sctp.o
+obj-$(CONFIG_NF_NAT_PROTO_ESP) += nf_nat_proto_esp.o
 
 # generic IP tables 
 obj-$(CONFIG_IP_NF_IPTABLES) += ip_tables.o
Index: linux-2.6.36/net/ipv4/netfilter/nf_nat_ipsec.c
===================================================================
--- linux-2.6.36.orig/net/ipv4/netfilter/nf_nat_ipsec.c	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/ipv4/netfilter/nf_nat_ipsec.c	2017-04-27 17:01:39.832819238 +0800
@@ -1,20 +1,24 @@
 /*
-<:copyright-gpl
- Copyright 2010 Broadcom Corp. All Rights Reserved.
+<:copyright-BRCM:2012:GPL/GPL:standard
 
- This program is free software; you can distribute it and/or modify it
- under the terms of the GNU General Public License (Version 2) as
- published by the Free Software Foundation.
-
- This program is distributed in the hope it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- for more details.
-
- You should have received a copy of the GNU General Public License along
- with this program; if not, write to the Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
-:>
+   Copyright (c) 2012 Broadcom Corporation
+   All Rights Reserved
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License, version 2, as published by
+the Free Software Foundation (the "GPL").
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+
+A copy of the GPL is available at http://www.broadcom.com/licenses/GPLv2.php, or by
+writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+:> 
 */
 
 #include <linux/module.h>
@@ -33,14 +37,6 @@
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("nf_nat_ipsec");
 
-#if 0
-#define DEBUGP(format, args...) printk(KERN_DEBUG "%s:%s: " format, __FILE__, \
-				       __FUNCTION__, ## args)
-#else
-#define DEBUGP(format, args...)
-#endif
-
-
 /* outbound packets == from LAN to WAN */
 static int
 ipsec_outbound_pkt(struct sk_buff *skb,
@@ -50,8 +46,10 @@
    struct iphdr *iph = ip_hdr(skb);
    struct udphdr *udph = (void *)iph + iph->ihl * 4;
 
+#if 0 //PeterSu
    /* make sure source port is 500 */
    udph->source = htons(IPSEC_PORT);
+#endif
    udph->check = 0;
    
    return NF_ACCEPT;
@@ -76,21 +74,21 @@
 
 static int __init nf_nat_helper_ipsec_init(void)
 {
-printk("@@@%s:%d\r\n",__FUNCTION__, __LINE__);
-   BUG_ON(rcu_dereference(nf_nat_ipsec_hook_outbound));
-   rcu_assign_pointer(nf_nat_ipsec_hook_outbound, ipsec_outbound_pkt);
+   BUG_ON(nf_nat_ipsec_hook_outbound != NULL);
+   RCU_INIT_POINTER(nf_nat_ipsec_hook_outbound, ipsec_outbound_pkt);
 
-   BUG_ON(rcu_dereference(nf_nat_ipsec_hook_inbound));
-   rcu_assign_pointer(nf_nat_ipsec_hook_inbound, ipsec_inbound_pkt);
+   BUG_ON(nf_nat_ipsec_hook_inbound != NULL);
+   RCU_INIT_POINTER(nf_nat_ipsec_hook_inbound, ipsec_inbound_pkt);
 
    return 0;
 }
 
 static void __exit nf_nat_helper_ipsec_fini(void)
 {
-   rcu_assign_pointer(nf_nat_ipsec_hook_inbound, NULL);
-   rcu_assign_pointer(nf_nat_ipsec_hook_outbound, NULL);
-   synchronize_rcu();
+	RCU_INIT_POINTER(nf_nat_ipsec_hook_inbound, NULL);
+	RCU_INIT_POINTER(nf_nat_ipsec_hook_outbound, NULL);
+
+	synchronize_rcu();
 }
 
 module_init(nf_nat_helper_ipsec_init);
Index: linux-2.6.36/net/ipv4/netfilter/nf_nat_proto_esp.c
===================================================================
--- linux-2.6.36.orig/net/ipv4/netfilter/nf_nat_proto_esp.c	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/ipv4/netfilter/nf_nat_proto_esp.c	2017-04-27 17:01:39.832819238 +0800
@@ -1,20 +1,24 @@
 /*
-<:copyright-gpl
- Copyright 2008 Broadcom Corp. All Rights Reserved.
+<:copyright-BRCM:2012:GPL/GPL:standard
 
- This program is free software; you can distribute it and/or modify it
- under the terms of the GNU General Public License (Version 2) as
- published by the Free Software Foundation.
-
- This program is distributed in the hope it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- for more details.
-
- You should have received a copy of the GNU General Public License along
- with this program; if not, write to the Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
-:>
+   Copyright (c) 2012 Broadcom Corporation
+   All Rights Reserved
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License, version 2, as published by
+the Free Software Foundation (the "GPL").
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+
+A copy of the GPL is available at http://www.broadcom.com/licenses/GPLv2.php, or by
+writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+:> 
 */
 /******************************************************************************
 Filename:       nf_nat_proto_esp.c
@@ -24,6 +28,7 @@
 Description:
     Implements the ESP ALG connectiontracking.
     Migrated to kernel 2.6.21.5 on April 16, 2008 by Dan-Han Tsai.
+    Migrated to kernel 3.4.11 on Jan 21, 2013 by Kirill Tsym
 *****************************************************************************/
 #include <linux/module.h>
 #include <linux/skbuff.h>
@@ -66,7 +71,6 @@
 {
    struct esphdr *esph;
    struct iphdr *iph = (struct iphdr *)(skb->data + iphdroff);
-//   struct iphdr *iph = ip_hdr(*pskb);
    unsigned int hdroff = iphdroff + iph->ihl * 4;
    __be32 oldip, newip;
 
Index: linux-2.6.36/net/netfilter/Kconfig
===================================================================
--- linux-2.6.36.orig/net/netfilter/Kconfig	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/netfilter/Kconfig	2017-04-27 17:01:39.832819238 +0800
@@ -99,16 +99,6 @@
 config NF_CT_PROTO_GRE
 	tristate
 
-config NF_CT_PROTO_ESP
-	tristate "ESP protocol support"
-	depends on NF_CONNTRACK
-	help
-	  Support the ESP protocol.  This allows ESP transports to be setup 
-	  properly.
-
-	  If you want to compile it as a module, say 'M' here and read
-	  Documentation/modules.txt.  If unsure, say 'Y'.
-
 config NF_CT_PROTO_SCTP
 	tristate 'SCTP protocol connection tracking support (EXPERIMENTAL)'
 	depends on EXPERIMENTAL
@@ -131,6 +121,15 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NF_CT_PROTO_ESP
+	tristate 'ESP protocol connection tracking support'
+	depends on NETFILTER_ADVANCED
+	help
+	  With this option enabled, the layer 3 ESP protocol 
+	  tracking will be able to do tracking on ESP connections
+	  
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NF_CONNTRACK_AMANDA
 	tristate "Amanda backup protocol support"
 	depends on NETFILTER_ADVANCED
@@ -259,6 +258,15 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NF_CONNTRACK_IPSEC
+	tristate "IPSEC protocol support"
+	default m if NETFILTER_ADVANCED=n
+	help
+	  IPSec is used for for securing IP communications by authenticating and 
+	  encrypting each IP packet of a communication session
+	  
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NF_CONNTRACK_TFTP
 	tristate "TFTP protocol support"
 	depends on NETFILTER_ADVANCED
@@ -280,13 +288,6 @@
  	  If you want to compile it as a module, say 'M' here and read       
  	  Documentation/modules.txt.  If unsure, say 'Y'.
 
-config NF_CONNTRACK_IPSEC
-	tristate "IPSEC protocol support"
-	depends on NF_CONNTRACK 
-	help
-	  Support the IPSEC protocol.  This allows UDP transports to be setup
-	  properly.
-
 config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface'
 	select NETFILTER_NETLINK
Index: linux-2.6.36/net/netfilter/Makefile
===================================================================
--- linux-2.6.36.orig/net/netfilter/Makefile	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/netfilter/Makefile	2017-04-27 17:01:39.832819238 +0800
@@ -15,9 +15,9 @@
 # SCTP protocol connection tracking
 obj-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
 obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
-obj-$(CONFIG_NF_CT_PROTO_ESP) += nf_conntrack_proto_esp.o
 obj-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
 obj-$(CONFIG_NF_CT_PROTO_UDPLITE) += nf_conntrack_proto_udplite.o
+obj-$(CONFIG_NF_CT_PROTO_ESP) += nf_conntrack_proto_esp.o
 
 # netlink interface for nf_conntrack
 obj-$(CONFIG_NF_CT_NETLINK) += nf_conntrack_netlink.o
Index: linux-2.6.36/net/netfilter/nf_conntrack_ipsec.c
===================================================================
--- linux-2.6.36.orig/net/netfilter/nf_conntrack_ipsec.c	2017-04-27 16:55:28.348819238 +0800
+++ linux-2.6.36/net/netfilter/nf_conntrack_ipsec.c	2017-04-27 17:01:39.832819238 +0800
@@ -1,20 +1,24 @@
 /*
-<:copyright-gpl
- Copyright 2010 Broadcom Corp. All Rights Reserved.
+<:copyright-BRCM:2012:GPL/GPL:standard
 
- This program is free software; you can distribute it and/or modify it
- under the terms of the GNU General Public License (Version 2) as
- published by the Free Software Foundation.
-
- This program is distributed in the hope it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- for more details.
-
- You should have received a copy of the GNU General Public License along
- with this program; if not, write to the Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
-:>
+   Copyright (c) 2012 Broadcom Corporation
+   All Rights Reserved
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License, version 2, as published by
+the Free Software Foundation (the "GPL").
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+
+A copy of the GPL is available at http://www.broadcom.com/licenses/GPLv2.php, or by
+writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+:> 
 */
 
 #include <linux/module.h>
@@ -25,10 +29,14 @@
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_core.h>
-#include <net/netfilter/nf_conntrack_expect.h>
 #include <net/netfilter/nf_conntrack_helper.h>
+#include <net/udp.h>
 #include <linux/netfilter/nf_conntrack_ipsec.h>
 
+#ifdef CONFIG_NF_BL_EXT
+#include <linux/netfilter.h>
+#endif /* CONFIG_NF_BL_EXT */
+
 MODULE_AUTHOR("Pavan Kumar <pavank@broadcom.com>");
 MODULE_DESCRIPTION("Netfilter connection tracking module for ipsec");
 MODULE_LICENSE("GPL");
@@ -46,19 +54,11 @@
       struct nf_conn *ct, enum ip_conntrack_info ctinfo, __be32 lan_ip) __read_mostly;
 EXPORT_SYMBOL_GPL(nf_nat_ipsec_hook_inbound);
 
-struct sk_buff nfskb_p;
+static void __exit nf_conntrack_ipsec_fini(void);
+
+#define CT_REFRESH_TIMEOUT (60 * HZ)	 /* KT: Changed from 13 Sec to 1 Min */
 
-#if 0
-#include <net/inet_sock.h>
-#define DEBUGP(format, args...)	printk(KERN_DEBUG "%s:%s: " format, __FILE__, __FUNCTION__, ## args)
-#else
-#define DEBUGP(format, args...)
-#endif
-
-#define REFRESH_TIMEOUT    (10 * HZ)
-#define CT_REFRESH_TIMEOUT (13 * HZ)
-#define CT_15MIN_TIME      (60 * HZ * 15)
-#define MAX_TIMEOUT_COUNT  ((CT_15MIN_TIME)/REFRESH_TIMEOUT)
+static unsigned int nf_conntrack_ipsec_refresh_timeout = CT_REFRESH_TIMEOUT;
 
 /* Internal table for ISAKMP */
 struct _ipsec_table 
@@ -66,62 +66,10 @@
    u_int32_t initcookie;
    __be32 lan_ip;
    struct nf_conn *ct;
-   struct timer_list refresh_timer;
    int pkt_rcvd;
-   int ntimeouts;
    int inuse;
 } ipsec_table[MAX_VPN_CONNECTION];
 
-static void ipsec_free_entry(unsigned long index)
-{
-   if( ipsec_table[index].inuse ) 
-   {
-      del_timer(&ipsec_table[index].refresh_timer);
-      memset(&ipsec_table[index], 0, sizeof(struct _ipsec_table));
-   }
-
-   DEBUGP("try to free ipsec_table[%ld] which is not in use\n", index);
-}
-
-static void ipsec_refresh_ct(unsigned long data)
-{
-//   int i;
-   struct _ipsec_table *ipsec_entry = NULL;
-
-   if( data > MAX_VPN_CONNECTION )
-      return;
-
-   ipsec_entry = &ipsec_table[data];
-
-   DEBUGP( "ntimeouts %d pkt_rcvd %d entry %p data %lu ct %p\n",
-          ipsec_entry->ntimeouts, ipsec_entry->pkt_rcvd, ipsec_entry, data,
-          ipsec_entry->ct);
-
-   if( ipsec_entry->pkt_rcvd ) 
-   {
-      ipsec_entry->pkt_rcvd = 0;
-      ipsec_entry->ntimeouts = 0;
-   } 
-   else 
-   {
-      ipsec_entry->ntimeouts++;
-      if( ipsec_entry->ntimeouts >= MAX_TIMEOUT_COUNT )
-      {
-         ipsec_free_entry(data);
-         return;
-      }
-   }
-   ipsec_entry->refresh_timer.expires = jiffies + REFRESH_TIMEOUT;
-   nfskb_p.nfct = (struct nf_conntrack *)ipsec_entry->ct;
-   nf_ct_refresh_acct(ipsec_entry->ct, 0, &nfskb_p, CT_REFRESH_TIMEOUT);
-   add_timer(&ipsec_entry->refresh_timer);
-#if 0
-   for( i=0;i<MAX_VPN_CONNECTION;i++ )
-      if( ipsec_table[i].inuse )
-         printk("table %d with lanIP %u.%u.%u.%u is inuse\n", i, NIPQUAD(ipsec_table[i].lan_ip));
-#endif
-}
-
 static struct _ipsec_table *ipsec_alloc_entry(int *index)
 {
    int idx = 0;
@@ -133,11 +81,8 @@
    
       *index = idx;
       memset(&ipsec_table[idx], 0, sizeof(struct _ipsec_table));
-      init_timer( &ipsec_table[idx].refresh_timer );
-      ipsec_table[idx].refresh_timer.expires = jiffies + REFRESH_TIMEOUT;
-      ipsec_table[idx].refresh_timer.function = ipsec_refresh_ct;
-      ipsec_table[idx].refresh_timer.data = (unsigned long)idx;
-      add_timer( &ipsec_table[idx].refresh_timer );      
+
+      pr_debug("([%d] alloc_entry()\n", idx);
 
       return (&ipsec_table[idx]);
    }
@@ -146,6 +91,33 @@
 }
 
 /*
+ * Search an IPsec table entry by ct.
+ */
+struct _ipsec_table *search_ipsec_entry_by_ct(struct nf_conn *ct)
+{
+   int idx = 0;
+
+   for( ; idx < MAX_VPN_CONNECTION; idx++)
+   {
+	  if (!ipsec_table[idx].inuse)
+		 continue;
+
+      pr_debug("Searching entry->ct(%p) <--> ct(%p)\n",
+         ipsec_table[idx].ct, ct);
+
+      /* check ct */
+      if (ipsec_table[idx].ct == ct)
+      {
+         pr_debug("Found entry with ct(%p)\n", ct);
+
+         return &ipsec_table[idx];
+      }
+   }
+   pr_debug("No Entry for ct(%p)\n", ct);
+   return NULL;
+}
+
+/*
  * Search an IPSEC table entry by the initiator cookie.
  */
 struct _ipsec_table *
@@ -156,7 +128,7 @@
 
    for( ; idx < MAX_VPN_CONNECTION; idx++ ) 
    {
-      DEBUGP("Searching initcookie %x <-> %x\n",
+	   pr_debug("Searching initcookie %x <-> %x\n",
           ntohl(isakmph->initcookie), ntohl(ipsec_entry->initcookie));
       
       if( isakmph->initcookie == ipsec_entry->initcookie ) 
@@ -179,12 +151,12 @@
 
    for( ; idx < MAX_VPN_CONNECTION; idx++ ) 
    {
-      DEBUGP("Looking up lan_ip=%u.%u.%u.%u table entry %u.%u.%u.%u\n", 
-              NIPQUAD(lan_ip), NIPQUAD(ipsec_entry->lan_ip));
+	   pr_debug("Looking up lan_ip=%pI4 table entry %pI4\n",
+              &lan_ip, &ipsec_entry->lan_ip);
 
       if( ntohl(ipsec_entry->lan_ip) == ntohl(lan_ip) ) 
       {
-         DEBUGP("Search by addr returning entry %p\n", ipsec_entry);
+    	  pr_debug("Search by addr returning entry %p\n", ipsec_entry);
 
          *index = idx;
          return ipsec_entry;
@@ -196,13 +168,13 @@
 }
 
 static inline int
-ipsec_inbound_pkt(struct sk_buff *skb, struct nf_conn *ct, 
+ipsec_inbound_pkt(struct sk_buff *skb, struct nf_conn *ct,
 		  enum ip_conntrack_info ctinfo, __be32 lan_ip)
 {
 //   struct nf_ct_ipsec_master *info = &nfct_help(ct)->help.ct_ipsec_info;
    typeof(nf_nat_ipsec_hook_inbound) nf_nat_ipsec_inbound;
 
-   DEBUGP("inbound ISAKMP packet for LAN %u.%u.%u.%u\n", NIPQUAD(lan_ip));
+   pr_debug("inbound ISAKMP packet for LAN %pI4\n", &lan_ip);
 
    nf_nat_ipsec_inbound = rcu_dereference(nf_nat_ipsec_hook_inbound);
    if (nf_nat_ipsec_inbound && ct->status & IPS_NAT_MASK)
@@ -220,7 +192,7 @@
 {
    typeof(nf_nat_ipsec_hook_outbound) nf_nat_ipsec_outbound;
 
-   DEBUGP("outbound ISAKMP packet\n");
+   pr_debug("outbound ISAKMP packet skb(%p)\n", skb);
 
    nf_nat_ipsec_outbound = rcu_dereference(nf_nat_ipsec_hook_outbound);
    if( nf_nat_ipsec_outbound && ct->status & IPS_NAT_MASK )
@@ -229,26 +201,28 @@
    return NF_ACCEPT;
 }
 
-
 /* track cookies inside ISAKMP, call expect_related */
 static int conntrack_ipsec_help(struct sk_buff *skb, unsigned int protoff,
                              struct nf_conn *ct, enum ip_conntrack_info ctinfo)
 {
    int dir = CTINFO2DIR(ctinfo);
    struct nf_ct_ipsec_master *info = &nfct_help(ct)->help.ct_ipsec_info;
-//   struct iphdr *iph = (*pskb)->nh.iph;
-   struct isakmp_pkt_hdr _isakmph, *isakmph;
+   struct isakmp_pkt_hdr _isakmph, *isakmph = NULL;
    struct _ipsec_table *ipsec_entry = ipsec_table;
-   unsigned int nexthdr_off;
    int ret, index=0;
 
-   nexthdr_off = protoff + 8;   /* UDP header length = 8 */
+   pr_debug("skb(%p) skb->data(%p) ct(%p) protoff(%d) offset(%d)\n", skb, skb->data, ct, protoff, (int) (protoff + sizeof(struct udphdr)));
+
+   isakmph = skb_header_pointer(skb, protoff + sizeof(struct udphdr), sizeof(_isakmph), &_isakmph);
+   if (isakmph == NULL)
+   {
+      pr_debug("ERR: no full ISAKMP header, can't track. isakmph=[%p]\n", isakmph);
+      return NF_ACCEPT;
+   }
 
-   isakmph = skb_header_pointer(skb, nexthdr_off, 
-                                sizeof(_isakmph), &_isakmph);
-   if( !isakmph ) 
+   if ( 0 == isakmph->initcookie )
    {
-      DEBUGP("no full ISAKMP header, can't track\n");
+      pr_debug("ERR: all zero ISAKMP initcookie.\n");
       return NF_ACCEPT;
    }
 
@@ -257,10 +231,6 @@
    if( dir == IP_CT_DIR_ORIGINAL )
    {
       int lan_ip = ct->tuplehash[dir].tuple.src.u3.ip;
-      DEBUGP("LAN -> WAN: old cookies:%x new cookies:%x, src: %u.%u.%u.%u, dst: %u.%u.%u.%u\n",
-              ntohl(info->initcookie), ntohl(isakmph->initcookie),
-	      NIPQUAD(ct->tuplehash[dir].tuple.src.u3.ip), 
-	      NIPQUAD(ct->tuplehash[dir].tuple.dst.u3.ip) );
       
       /* create one entry in the internal table if a new connection is found */
       if( (ipsec_entry = search_ipsec_entry_by_cookie(isakmph)) == NULL ) 
@@ -273,46 +243,60 @@
             if( ipsec_entry == NULL ) 
             {
                /* All entries are currently in use */
-               DEBUGP("%s:%s Out of table entries\n", __FILE__, __FUNCTION__);
+               pr_debug("ERR: Too many sessions. ct(%p)\n", ct);
                spin_unlock_bh(&nf_ipsec_lock);
                return NF_DROP;
             }
             
+            ipsec_entry->ct = ct; /* KT: Guess it should be here */
+            ipsec_entry->initcookie = isakmph->initcookie; /* KT: Update our cookie information - moved to here */
             ipsec_entry->lan_ip = ct->tuplehash[dir].tuple.src.u3.ip;
             ipsec_entry->inuse = 1;
+
+            pr_debug("NEW ipsec_entry[%d] with ct=%p, lan_ip=%pI4, initcookie=%x\n",
+				index, ipsec_entry->ct, &ipsec_entry->lan_ip,
+				ntohl(ipsec_entry->initcookie) );
+         } else {
+             pr_debug("EXISTING ipsec_entry[%d] with ct=%p, lan_ip=%pI4, initcookie=%x\n",
+ 				index, ipsec_entry->ct, &ipsec_entry->lan_ip,
+ 				ntohl(ipsec_entry->initcookie) );
          }
-         /* Update our cookie information */
-         ipsec_entry->initcookie = isakmph->initcookie;
-         ipsec_entry->ct = ct;
-
-         DEBUGP("create a new ipsec_entry with ct=%p, lan_ip=%u.%u.%u.%u, initcookie=%x\n", 
-            ipsec_entry->ct, NIPQUAD(ipsec_entry->lan_ip), 
-            ntohl(ipsec_entry->initcookie) );
       }
       ipsec_entry->pkt_rcvd++;
 
       info->initcookie = isakmph->initcookie;
       info->lan_ip = ct->tuplehash[dir].tuple.src.u3.ip;
 
-      DEBUGP("ct_ipsec_info => initcookie=%x, lan_ip=%u.%u.%u.%u, ct->tuplehash[%d].tuple.src.u3.ip=%u.%u.%u.%u, ct->tuplehash[%d].tuple.dst.u3.ip=%u.%u.%u.%u\n\n", 
-              info->initcookie, NIPQUAD(info->lan_ip), 
-              dir, NIPQUAD(ct->tuplehash[dir].tuple.src.u3.ip), 
-              dir, NIPQUAD(ct->tuplehash[dir].tuple.dst.u3.ip));
+      pr_debug("L->W: initcookie=%x, lan_ip=%pI4, dir[%d] src.u3.ip=%pI4, dst.u3.ip=%pI4\n",
+              info->initcookie, &info->lan_ip,
+              dir,
+              &ct->tuplehash[dir].tuple.src.u3.ip,
+              &ct->tuplehash[dir].tuple.dst.u3.ip);
       
-      ret = ipsec_outbound_pkt(skb, ct, ctinfo); 
+      nf_ct_refresh_acct(ipsec_entry->ct, 0, skb, CT_REFRESH_TIMEOUT);
+
+      ret = ipsec_outbound_pkt(skb, ct, ctinfo);
    }
    else
    {
-      DEBUGP("WAN->LAN\n");
+	  pr_debug("WAN->LAN ct=%p\n", ct);
       
       if( (ipsec_entry = search_ipsec_entry_by_cookie(isakmph)) != NULL )
       {
+    	 nf_ct_refresh_acct(ipsec_entry->ct, 0, skb, CT_REFRESH_TIMEOUT);
          ipsec_entry->pkt_rcvd++;
+
+         pr_debug("W->L: initcookie=%x, lan_ip=%pI4, dir[%d] src.u3.ip=%pI4, dst.u3.ip=%pI4\n",
+              info->initcookie, &info->lan_ip,
+              dir,
+              &ct->tuplehash[dir].tuple.src.u3.ip,
+              &ct->tuplehash[dir].tuple.dst.u3.ip);
+
          ret = ipsec_inbound_pkt(skb, ct, ctinfo, ipsec_entry->lan_ip);
       }
       else
       {
-         DEBUGP("WARNNING: client from WAN tries to connect to VPN server in the LAN\n");
+    	 pr_debug("WARNNING: client from WAN tries to connect to VPN server in the LAN. ipsec_entry=[%p]\n", ipsec_entry);
          ret = NF_ACCEPT;
       }
    }
@@ -322,37 +306,89 @@
    return ret;
 }
 
-/* ISAKMP protocol helper */
-static struct nf_conntrack_expect_policy ipsec_exp_policy = {
-   .max_expected = 1,
-   .timeout = 300,
+/* Called when the connection is deleted. */
+static void ipsec_destroy(struct nf_conn *ct)
+{
+	struct _ipsec_table *ipsec_entry = NULL;
+
+	spin_lock_bh(&nf_ipsec_lock);
+	pr_debug("DEL IPsec entry ct(%p)\n", ct);
+	if ((ipsec_entry = search_ipsec_entry_by_ct(ct))) {
+		memset(ipsec_entry, 0, sizeof(struct _ipsec_table));
+	} else {
+		pr_debug("DEL IPsec entry failed: ct(%p)\n", ct);
+	}
+	spin_unlock_bh(&nf_ipsec_lock);
+}
+
+#ifdef CONFIG_SYSCTL
+
+static struct ctl_table_header *nf_ct_netfilter_header;
+
+static ctl_table nf_child_table[] = {
+	{
+		.procname	= "nf_conntrack_ipsec_refresh_timeout",
+		.data		= &nf_conntrack_ipsec_refresh_timeout,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static ctl_table nf_dir_table[] = {
+	{
+		.procname	= "netfilter",
+		.mode		= 0644,
+		.child		= nf_child_table
+	},
+	{ .procname = NULL }
 };
 
+static ctl_table nf_root_table[] = {
+	{
+		.procname	= "net",
+		.mode		= 0644,
+		.child		= nf_dir_table
+	},
+	{ .procname = NULL }
+};
+
+
+#endif /* CONFIG_SYSCTL */
+
+static const struct nf_conntrack_expect_policy ipsec_exp_policy = {
+	.max_expected	= 3,
+	.timeout		= 300,
+};
+
+/* ISAKMP protocol helper */
 static struct nf_conntrack_helper ipsec __read_mostly = {
    .name = "ipsec",
    .me = THIS_MODULE,
    .tuple.src.l3num = AF_INET,
    .tuple.dst.protonum = IPPROTO_UDP,
    .tuple.src.u.udp.port = __constant_htons(IPSEC_PORT),
-//   .mask.src.l3num = 0xffff,
-//   .mask.dst.protonum = 0xff,
-//   .mask.src.u.udp.port	= __constant_htons(0xffff),
+
    .help = conntrack_ipsec_help,
-   .expect_policy = &ipsec_exp_policy,
+   .destroy = ipsec_destroy,
+   .expect_policy		= &ipsec_exp_policy,
 };
 
 static int __init nf_conntrack_ipsec_init(void)
 {
+#ifdef CONFIG_SYSCTL
+   nf_ct_netfilter_header = register_sysctl_table(nf_root_table);
+#endif /* CONFIG_SYSCTL */
+
    return nf_conntrack_helper_register(&ipsec);
 }
 
 static void __exit nf_conntrack_ipsec_fini(void)
 {
-   int idx = 0;
-
-   for( ; idx < MAX_VPN_CONNECTION; idx++ )
-      if( ipsec_table[idx].inuse )
-         del_timer(&ipsec_table[idx].refresh_timer);
+#ifdef CONFIG_SYSCTL
+   unregister_sysctl_table(nf_ct_netfilter_header);
+#endif /* CONFIG_SYSCTL */
 
    nf_conntrack_helper_unregister(&ipsec);
 }
Index: linux-2.6.36/net/netfilter/nf_conntrack_proto_esp.c
===================================================================
--- linux-2.6.36.orig/net/netfilter/nf_conntrack_proto_esp.c	2017-04-27 16:55:28.352819238 +0800
+++ linux-2.6.36/net/netfilter/nf_conntrack_proto_esp.c	2017-04-27 17:01:39.832819238 +0800
@@ -1,20 +1,24 @@
 /*
-<:copyright-gpl
- Copyright 2008 Broadcom Corp. All Rights Reserved.
+<:copyright-BRCM:2012:GPL/GPL:standard
 
- This program is free software; you can distribute it and/or modify it
- under the terms of the GNU General Public License (Version 2) as
- published by the Free Software Foundation.
-
- This program is distributed in the hope it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- for more details.
-
- You should have received a copy of the GNU General Public License along
- with this program; if not, write to the Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
-:>
+   Copyright (c) 2012 Broadcom Corporation
+   All Rights Reserved
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License, version 2, as published by
+the Free Software Foundation (the "GPL").
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+
+A copy of the GPL is available at http://www.broadcom.com/licenses/GPLv2.php, or by
+writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+:> 
 */
 /******************************************************************************
  Filename:       nf_conntrack_proto_esp.c
@@ -22,8 +26,9 @@
  Creation Date:  05/27/04
 
  Description:
-  Implements the ESP ALG connectiontracking.
+  Implements the ESP ALG connection tracking.
   Migrated to kernel 2.6.21.5 on April 16, 2008 by Dan-Han Tsai.
+  Migrated to kernel 3.4.11 on Jan 21, 2013 by Kirill Tsym
 *****************************************************************************/
 
 #include <linux/module.h>
@@ -40,20 +45,19 @@
 #include <net/netfilter/nf_conntrack_core.h>
 #include <linux/netfilter/nf_conntrack_proto_esp.h>
 
-#if 1
-#define DEBUGP(format, args...)	printk(KERN_DEBUG "%s: " format, __FUNCTION__, ## args)
-#else
-#define DEBUGP(x, args...)
-#endif
+enum grep_conntrack {
+	ESP_CT_UNREPLIED,
+	ESP_CT_REPLIED,
+	ESP_CT_MAX
+};
 
-#define ESP_REF_TMOUT   (30 * HZ)
-#define ESP_CONN_TMOUT  (60 * HZ * 6)
-#define ESP_TMOUT_COUNT (ESP_CONN_TMOUT/ESP_REF_TMOUT)
-#define ESP_STREAM_TIMEOUT (6000 * HZ)
-#define ESP_TIMEOUT (3000 * HZ)
+static unsigned int esp_timeouts[ESP_CT_MAX] = {
+	[ESP_CT_UNREPLIED]	= 30*HZ,
+	[ESP_CT_REPLIED]	= 60*HZ,
+};
 
 #define IPSEC_INUSE    1
-#define MAX_PORTS      64
+#define MAX_PORTS      8 			/* KT: Changed to match MAX_VPN_CONNECTION */
 #define TEMP_SPI_START 1500
 
 struct _esp_table 
@@ -65,63 +69,13 @@
    u_int32_t timeout;
    u_int16_t tspi;
    struct nf_conn *ct;
-   struct timer_list refresh_timer;
    int    pkt_rcvd;
-   int    ntimeouts;
    int    inuse;
 };
 
 static struct _esp_table esp_table[MAX_PORTS];
-static struct sk_buff nfskb_p;
-
-static void esp_free_entry( int index )
-{
-   if( esp_table[index].inuse ) 
-   {
-      DEBUGP( "   %s Deleting timer index %d\n", 
-               __FUNCTION__, index);
-      del_timer(&esp_table[index].refresh_timer);
-      memset(&esp_table[index], 0, sizeof(struct _esp_table));
-   }
-}
-
-static void esp_refresh_ct( unsigned long data )
-{
-   struct _esp_table *esp_entry = NULL;
-
-   if( data > MAX_PORTS ) 
-      return;
 
-   if( (esp_entry = &esp_table[data]) == NULL )
-      return;
-
-   DEBUGP( "   ntimeouts %d pkt_rcvd %d entry %p data %lu ct %p spi [0x%x - 0x%x] %u.%u.%u.%u <-> %u.%u.%u.%u\n", 
-         esp_entry->ntimeouts, esp_entry->pkt_rcvd, esp_entry, data, esp_entry->ct, esp_entry->l_spi, esp_entry->r_spi, NIPQUAD(esp_entry->l_ip), NIPQUAD(esp_entry->r_ip));
-
-   if( esp_entry->pkt_rcvd )
-   {
-      esp_entry->pkt_rcvd  = 0;
-      esp_entry->ntimeouts = 0;
-   } 
-   else 
-   {
-      esp_entry->ntimeouts++;
-      if( esp_entry->ntimeouts >= ESP_TMOUT_COUNT )
-      {
-         esp_free_entry(data);
-         return;
-      }
-   }
-   if( esp_entry->ct )
-   {
-      esp_entry->refresh_timer.expires = jiffies + ESP_REF_TMOUT;
-      esp_entry->refresh_timer.function = esp_refresh_ct;
-      esp_entry->refresh_timer.data = data;
-      nfskb_p.nfct = (struct nf_conntrack *)esp_entry->ct;
-      nf_ct_refresh_acct(esp_entry->ct, 0, &nfskb_p, ESP_CONN_TMOUT);
-      add_timer(&esp_entry->refresh_timer);
-   }
-}
+static unsigned int nf_conntrack_esp_stream_timeout = ESP_CT_REPLIED;
 
 /*
  * Allocate a free IPSEC table entry.
@@ -139,20 +93,42 @@
       esp_table[idx].tspi  = idx + TEMP_SPI_START;
       esp_table[idx].inuse = IPSEC_INUSE;
 
-      DEBUGP( "   %s New esp_entry at idx %d tspi %u \n", 
-         __FUNCTION__, idx, esp_table[idx].tspi );
+      pr_debug("[%d] alloc_entry() tspi(%u)\n", idx, esp_table[idx].tspi);
 
-      init_timer(&esp_table[idx].refresh_timer);
-      esp_table[idx].refresh_timer.data = idx;
-      esp_table[idx].refresh_timer.expires = jiffies + ESP_REF_TMOUT;
-      esp_table[idx].refresh_timer.function = esp_refresh_ct;
-      add_timer(&esp_table[idx].refresh_timer);
       return (&esp_table[idx]);
    }
    return NULL;
 }
 
 /*
+ * Search an ESP table entry by ct.
+ */
+struct _esp_table *search_esp_entry_by_ct(struct nf_conn *ct)
+{
+   int idx = 0;
+
+   for( ; idx < MAX_PORTS; idx++)
+   {
+	  if(esp_table[idx].inuse != IPSEC_INUSE )
+		 continue;
+
+      pr_debug("Searching entry->ct(%p) <--> ct(%p)\n",
+         esp_table[idx].ct, ct);
+
+      /* checking ct */
+      if(esp_table[idx].ct == ct)
+      {
+         pr_debug("Found entry with ct(%p)\n", ct);
+
+         return &esp_table[idx];
+      }
+   }
+
+   pr_debug("No Entry for ct(%p)\n", ct);
+   return NULL;
+}
+
+/*
  * Search an ESP table entry by source IP.
  * If found one, update the spi value
  */
@@ -165,14 +141,14 @@
 
    for( ; idx < MAX_PORTS; idx++, esp_entry++ )
    {
-      DEBUGP("   Searching IP %u.%u.%u.%u <-> %u.%u.%u.%u,  %u.%u.%u.%u\n",
-          NIPQUAD(srcIP), NIPQUAD(esp_entry->l_ip), 
-          NIPQUAD(esp_entry->r_ip));
+      pr_debug("   Searching IP %pI4 <-> %pI4,  %pI4\n",
+          &srcIP, &esp_entry->l_ip,
+          &esp_entry->r_ip);
       
       /* make sure l_ip is LAN IP */
       if( (srcIP == esp_entry->l_ip) && (((unsigned char *)&(srcIP))[0] == 192) )
       {
-         DEBUGP("   found entry with l_ip\n");
+         pr_debug("   found entry with l_ip\n");
          esp_entry->l_spi = spi;
 
          /* This is a new connection of the same LAN host */
@@ -185,19 +161,19 @@
       }
       else if( srcIP == esp_entry->r_ip )
       {
-         DEBUGP("   found entry with r_ip\n");
+         pr_debug("   found entry with r_ip\n");
          /* FIXME */
          if( esp_entry->r_spi == 0 )
          {
-            DEBUGP("   found entry with r_ip and r_spi == 0\n");
+            pr_debug("   found entry with r_ip and r_spi == 0\n");
             esp_entry->r_spi = spi;
             return esp_entry;
          }
 	 /* We cannot handle spi changed at WAN side */
-         DEBUGP("   found entry with r_ip but r_spi != 0\n");
+         pr_debug("   found entry with r_ip but r_spi != 0\n");
       }
    }
-   DEBUGP( "   %s No Entry\n", __FUNCTION__);
+   pr_debug("No Entry for spi(0x%x)\n", spi);
    return NULL;
 }
 
@@ -206,46 +182,47 @@
  */
 struct _esp_table *search_esp_entry_by_spi( const __u32 spi, const __u32 srcIP )
 {
-   int idx = 0;
-   struct _esp_table *esp_entry = esp_table;
-
-   for( ; idx < MAX_PORTS; idx++, esp_entry++ )
-   {
-      DEBUGP("   Searching spi %x <-> %x, %x\n",
-          spi, esp_entry->l_spi, esp_entry->r_spi);
-      
-      if( (spi == esp_entry->l_spi) || (spi == esp_entry->r_spi) )
-      {
-         DEBUGP("   In %s, found entry %d with tspi %u\n",
-                  __FUNCTION__, idx, esp_entry->tspi);
-
-         /* l_spi and r_spi may be the same */
-         if( (spi == esp_entry->l_spi) && (srcIP == esp_entry->r_ip) )
-	 {
-            DEBUGP("  In %s, l_spi==r_spi\n",  __FUNCTION__);
-            esp_entry->r_spi = spi;
-	 }
+	int idx = 0;
+	struct _esp_table *esp_entry = esp_table;
 
-         return esp_entry;
-      }
-   }
-   DEBUGP( "   %s No Entry\n", __FUNCTION__);
-   return NULL;
+	for( ; idx < MAX_PORTS; idx++, esp_entry++ )
+	{
+		pr_debug("   Searching spi 0x%x <-> 0x%x, 0x%x\n",
+		spi, esp_entry->l_spi, esp_entry->r_spi);
+
+		if( (spi == esp_entry->l_spi) || (spi == esp_entry->r_spi) )
+		{
+			pr_debug("   In %s, found entry %d with tspi %u\n",
+			  __FUNCTION__, idx, esp_entry->tspi);
+
+			/* l_spi and r_spi may be the same */
+			if( (spi == esp_entry->l_spi) && (srcIP == esp_entry->r_ip) )
+			{
+				pr_debug("l_spi(0x%x)==r_spi\n", spi);
+				esp_entry->r_spi = spi;
+			}
+
+			return esp_entry;
+		}
+	}
+	pr_debug("No Entry for spi(0x%x)\n", spi);
 
+	return NULL;
 }
 
 /* invert esp part of tuple */
-static int esp_invert_tuple(struct nf_conntrack_tuple *tuple,
+static bool esp_invert_tuple(struct nf_conntrack_tuple *tuple,
 			    const struct nf_conntrack_tuple *orig)
 {
-   DEBUGP("%s with spi = 0x%u\n",  __FUNCTION__, orig->src.u.esp.spi);
+   pr_debug("with spi = %u\n", orig->src.u.esp.spi);
+
    tuple->dst.u.esp.spi = orig->dst.u.esp.spi;
    tuple->src.u.esp.spi = orig->src.u.esp.spi;
-   return 1;
+   return true;
 }
 
 /* esp hdr info to tuple */
-static int esp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
+static bool esp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
                             struct nf_conntrack_tuple *tuple)
 {
    struct esphdr _esphdr, *esphdr;
@@ -257,50 +234,55 @@
       /* try to behave like "nf_conntrack_proto_generic" */
       tuple->src.u.all = 0;
       tuple->dst.u.all = 0;
-      return 1;
+      return true;
    }
 
-   DEBUGP("Enter pkt_to_tuple() with spi %x\n", esphdr->spi);
+   pr_debug("Enter pkt_to_tuple() with spi 0x%x\n", esphdr->spi);
    /* check if esphdr has a new SPI:
     *   if no, update tuple with correct tspi and increment pkt count;
     *   if yes, check if we have seen the source IP:
     *             if yes, do the tspi and pkt count update
     *             if no, create a new entry
     */
-   if( (esp_entry = search_esp_entry_by_spi(esphdr->spi, tuple->src.u3.ip)) == NULL ) 
+
+   if( ((esp_entry = search_esp_entry_by_spi(esphdr->spi, tuple->src.u3.ip)) == NULL) )
    {
       if( (esp_entry = 
            search_esp_entry_by_ip(tuple, esphdr->spi)) == NULL )
       {
 #if 0
-         /* Because SA is simplex, it's possible that WAN starts connection first. 
+      /* Because SA is simplex, it's possible that WAN starts connection first.
 	  * We need to make sure that the connection starts from LAN.
 	  */
          if( ((unsigned char *)&(tuple->src.u3.ip))[0] != 192 )
 	 {
- 	      DEBUGP("srcIP %u.%u.%u.%u is WAN IP, DROP packet\n", NIPQUAD(tuple->src.u3.ip));
-	      return 0;
+ 	      pr_debug("srcIP %pI4 is WAN IP, DROP packet\n", &tuple->src.u3.ip);
+	      return false;
 	 }
 #endif
          esp_entry = alloc_esp_entry();
          if( esp_entry == NULL ) 
          {
-            DEBUGP( "%s All entries in use\n", __FUNCTION__);
-            return 0;
+            pr_debug("Too many entries. New spi(0x%x)\n", esphdr->spi);
+            return false;
          }
+
          esp_entry->l_spi = esphdr->spi;
          esp_entry->l_ip = tuple->src.u3.ip;
          esp_entry->r_ip = tuple->dst.u3.ip;
       }
+
    }
 
-   DEBUGP( "%s: entry_info: tspi %u l_spi 0x%x r_spi 0x%x l_ip %u.%u.%u.%u r_ip %u.%u.%u.%u srcIP %u.%u.%u.%u dstIP %u.%u.%u.%u\n",
-         __FUNCTION__, esp_entry->tspi, esp_entry->l_spi, esp_entry->r_spi, NIPQUAD(esp_entry->l_ip), NIPQUAD(esp_entry->r_ip), NIPQUAD(tuple->src.u3.ip), NIPQUAD(tuple->dst.u3.ip) );
+   pr_debug("esp_entry: tspi(%u) l_ip[%pI4]-->r_ip[%pI4] tuple: srcIP[%pI4]-->dstIP[%pI4]\n",
+         esp_entry->tspi,
+         &esp_entry->l_ip, &esp_entry->r_ip,
+         &tuple->src.u3.ip, &tuple->dst.u3.ip);
 
    tuple->dst.u.esp.spi = tuple->src.u.esp.spi = esp_entry->tspi;
    esp_entry->pkt_rcvd++;
 
-   return 1;
+   return true;
 }
 
 /* print esp part of tuple */
@@ -319,57 +301,121 @@
                     (ct->proto.esp.stream_timeout / HZ));
 }
 
+static unsigned int *esp_get_timeouts(struct net *net)
+{
+	return esp_timeouts;
+}
+
 /* Returns verdict for packet, and may modify conntrack */
-static int esp_packet(struct nf_conn *ct, const struct sk_buff *skb,
-                      unsigned int dataoff, enum ip_conntrack_info ctinfo,
-                      int pf, unsigned int hooknum)
+static int esp_packet(struct nf_conn *ct,
+				const struct sk_buff *skb,
+                unsigned int dataoff,
+                enum ip_conntrack_info ctinfo,
+                u_int8_t pf,
+                unsigned int hooknum/*,
+  		        unsigned int *timeouts*/)
 {
-   const struct iphdr *iph = ip_hdr(skb);
    struct esphdr _esphdr, *esphdr;
+   struct iphdr *iph = ip_hdr(skb);
 
    esphdr = skb_header_pointer(skb, dataoff, sizeof(_esphdr), &_esphdr);
 
-   DEBUGP("%s (0x%x) %u.%u.%u.%u <-> %u.%u.%u.%u status %s info %d %s\n", __FUNCTION__, esphdr->spi, NIPQUAD(iph->saddr), NIPQUAD(iph->daddr), (ct->status & IPS_SEEN_REPLY) ? "SEEN" : "NOT_SEEN", ctinfo, (ctinfo == IP_CT_NEW ) ? "CT_NEW" : "SEEN_REPLY" );
+   pr_debug("(0x%x) %pI4 <-> %pI4 status %s info %d %s\n",
+	  esphdr->spi, &iph->saddr, &iph->daddr, (ct->status & IPS_SEEN_REPLY) ? "SEEN" : "NOT_SEEN",
+	  ctinfo, (ctinfo == IP_CT_NEW ) ? "CT_NEW" : "SEEN_REPLY" );
 
    /* If we've seen traffic both ways, this is some kind of ESP
       stream.  Extend timeout. */
    if( test_bit(IPS_SEEN_REPLY_BIT, &ct->status) ) 
    {
-      nf_ct_refresh_acct(ct, ctinfo, skb, ESP_STREAM_TIMEOUT);
+      nf_ct_refresh_acct(ct, ctinfo, skb, ct->proto.esp.stream_timeout);
       /* Also, more likely to be important, and not a probe */
       if( !test_and_set_bit(IPS_ASSURED_BIT, &ct->status) )
          nf_conntrack_event_cache(IPCT_ASSURED, ct);
    } 
    else
-      nf_ct_refresh_acct(ct, ctinfo, skb, ESP_TIMEOUT);
+      nf_ct_refresh_acct(ct, ctinfo, skb, ct->proto.esp.timeout);
 
    return NF_ACCEPT;
 }
 
 /* Called when a new connection for this protocol found. */
-static int esp_new(struct nf_conn *ct, const struct sk_buff *skb,
-                   unsigned int dataoff)
+static bool esp_new(struct nf_conn *ct, const struct sk_buff *skb,
+                   unsigned int dataoff/*, unsigned int *timeouts*/)
 {
-   const struct iphdr *iph = ip_hdr(skb);
+   struct iphdr *iph = ip_hdr(skb);
    struct _esp_table *esp_entry;
    struct esphdr _esphdr, *esphdr;
 
-   ct->proto.esp.stream_timeout = ESP_STREAM_TIMEOUT;
-   ct->proto.esp.timeout = ESP_TIMEOUT;
+//   ct->proto.esp.stream_timeout = timeouts[ESP_CT_UNREPLIED];
+   ct->proto.esp.stream_timeout = esp_timeouts[ESP_CT_UNREPLIED];
+//   ct->proto.esp.timeout = timeouts[ESP_CT_UNREPLIED];
+   ct->proto.esp.timeout = esp_timeouts[ESP_CT_UNREPLIED];
 
    esphdr = skb_header_pointer(skb, dataoff, sizeof(_esphdr), &_esphdr);
 
-   DEBUGP("%s SPI(0x%x) %u.%u.%u.%u <-> %u.%u.%u.%u ct %p\n",
-           __FUNCTION__, esphdr->spi, NIPQUAD(iph->saddr), NIPQUAD(iph->daddr), ct);
+   pr_debug("NEW SPI(0x%x) %pI4 <-> %pI4 ct(%p)\n",
+     esphdr->spi, &iph->saddr, &iph->daddr, ct);
 
-   if( (esp_entry = search_esp_entry_by_spi(esphdr->spi, 0)) != NULL ) 
+   if( (esp_entry = search_esp_entry_by_spi(esphdr->spi, 0)) != NULL ) {
       esp_entry->ct = ct;
-   else
-      DEBUGP("In esp_new(), cannot find an entry with SPI %x\n", esphdr->spi);
+   } else {
+	  pr_debug("ERR: In esp_new(), cannot find an entry with SPI %x\n", esphdr->spi);
+      return false;
+   }
+
+   return true;
+}
+
+/* Called when the connection is deleted. */
+static void esp_destroy(struct nf_conn *ct)
+{
+	struct _esp_table *esp_entry = NULL;
 
-   return 1;
+	pr_debug("DEL ESP entry ct(%p)\n", ct);
+	if ((esp_entry = search_esp_entry_by_ct(ct))) {
+		memset(esp_entry, 0, sizeof(struct _esp_table));
+	} else {
+		pr_debug("ERR: DEL ESP Failed for ct(%p): no such entry\n", ct);
+	}
 }
 
+#ifdef CONFIG_SYSCTL
+
+static struct ctl_table_header *nf_ct_netfilter_header;
+
+static ctl_table nf_child_table[] = {
+	{
+		.procname	= "nf_conntrack_esp_stream_timeout",
+		.data		= &nf_conntrack_esp_stream_timeout,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static ctl_table nf_dir_table[] = {
+	{
+		.procname	= "netfilter",
+		.mode		= 0644,
+		.child		= nf_child_table
+	},
+	{ .procname = NULL }
+};
+
+static ctl_table nf_root_table[] = {
+	{
+		.procname	= "net",
+		.mode		= 0644,
+		.child		= nf_dir_table
+	},
+	{ .procname = NULL }
+};
+
+
+#endif /* CONFIG_SYSCTL */
+
 /* protocol helper struct */
 struct nf_conntrack_l4proto nf_conntrack_l4proto_esp4 = {
    .l3proto = PF_INET,
@@ -379,23 +425,27 @@
    .invert_tuple = esp_invert_tuple,
    .print_tuple = esp_print_tuple,
    .print_conntrack = esp_print_conntrack,
+   .get_timeouts    = esp_get_timeouts,
    .packet = esp_packet,
    .new = esp_new,
+   .destroy = esp_destroy,
    .me = THIS_MODULE,
 };
 
 int __init nf_ct_proto_esp_init(void)
 {
+#ifdef CONFIG_SYSCTL
+   nf_ct_netfilter_header = register_sysctl_table(nf_root_table);
+#endif /* CONFIG_SYSCTL */
+
    return nf_conntrack_l4proto_register(&nf_conntrack_l4proto_esp4);
 }
 
 void __exit nf_ct_proto_esp_fini(void)
 {
-   int idx = 0;
-
-   for( ; idx < MAX_PORTS; idx++ )
-      if( esp_table[idx].inuse == IPSEC_INUSE )
-         del_timer(&esp_table[idx].refresh_timer);
+#ifdef CONFIG_SYSCTL
+   unregister_sysctl_table(nf_ct_netfilter_header);
+#endif /* CONFIG_SYSCTL */
 
    nf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_esp4);
 }
