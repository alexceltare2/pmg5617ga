Index: linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h
===================================================================
--- linux-2.6.36.orig/arch/mips/include/asm/tc3162/tc3162.h	2017-04-22 16:45:21.000000000 +0800
+++ linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h	2017-04-24 17:21:28.207443190 +0800
@@ -226,6 +226,7 @@
 
 #define EFUSE_VERIFY_DATA0 (0xBFBF8214)
 #define EFUSE_PKG_MASK          (0x3F)
+#define EFUSE_PKG_INGORE_BITE0_MASK          (0x3C)
 #define EFUSE_REMARK_BIT        (1<<6)
 
 #define EFUSE_PKG_REMARK_SHITF 7
@@ -242,15 +243,28 @@
 #define EFUSE_EN7586    (0xA)
 #define EFUSE_EN7586    (0xA)
 
-#define isEN7526F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+#define isEN7526F (isEN7526c? \
+				((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_INGORE_BITE0_MASK)== EFUSE_EN7526F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_INGORE_BITE0_MASK)==EFUSE_EN7526F)): \
+				(isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
                         (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526F): \
-                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526F)))
-#define isEN7521F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526F))))
+#define isEN7526FP (isEN7526c & isEN7526F & (((VPint(0xBFA201EC) & (1<<10)))==(1<<10)))
+#define isEN7521F (isEN7526c? \
+				((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_INGORE_BITE0_MASK)== EFUSE_EN7521F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_INGORE_BITE0_MASK)==EFUSE_EN7521F)): \
+				(isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
                         (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521F): \
-                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521F)))
-#define isEN7521S (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521F))))
+#define isEN7521S (isEN7526c? \
+				((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_INGORE_BITE0_MASK)== EFUSE_EN7521S): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_INGORE_BITE0_MASK)==EFUSE_EN7521S)): \
+				(isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
                         (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521S): \
-                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521S)))
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521S))))
 #define isEN7512 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
                         (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7512): \
                         ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7512)))
@@ -335,7 +349,7 @@
 #define	SAR_CLK	(SYS_HCLK)/(4.0)		//more accurate if 4.0 not 4
 
 /* define CPU timer clock, FPGA is 50Mhz, ASIC is 250Mhz */
-#define	CPUTMR_CLK		(isFPGA ? (50*1000000) : (isEN751221 ? (200*1000000) : (isMT7505 ? (100*1000000) : (isMT751020 ? (800*1000000/3) :(250*1000000)))))
+#define	CPUTMR_CLK		(isFPGA ? (50000000) : (isEN751221 ? (200000000) : (isMT7505 ? (100000000) : (isMT751020 ? (800000000/3) :(250000000)))))
 
 #if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
 #define DSPRAM_BASE		0x9dff8000
@@ -359,6 +373,14 @@
 #if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
 #define IS_SPIFLASH		((~(VPint(0xBFA10114))) & 0x2)
 #define IS_NANDFLASH		(VPint(0xBFA10114) & 0x2)
+#define isSpiControllerECC	((isEN7526c) ? \
+								(isFPGA ? \
+									/* EN7526c FPGA has no controller ECC HW trap. */ \
+									(isEN7526c ? 1 : ((VPint(CR_AHB_HWCONF) & (1<<19)) == 0)) : \
+									((VPint(CR_AHB_HWCONF) & (1<<0)) == 0)) : \
+								(0))
+
+#define isSpiNandAndCtrlECC 	(IS_NANDFLASH && isSpiControllerECC)
 #else
 #if defined(TCSUPPORT_CPU_MT7505)
 #define IS_SPIFLASH		1
Index: linux-2.6.36/drivers/mtd/chips/Makefile
===================================================================
--- linux-2.6.36.orig/drivers/mtd/chips/Makefile	2017-04-22 16:45:21.000000000 +0800
+++ linux-2.6.36/drivers/mtd/chips/Makefile	2017-04-24 17:21:28.211443190 +0800
@@ -18,6 +18,8 @@
 ifneq ($(strip $(TCSUPPORT_CPU_EN7512) $(TCSUPPORT_CPU_EN7521)),)
 obj-y += spi_nand_flash.o
 obj-y += spi_controller.o
+obj-y += spi_ecc.o
+obj-y += spi_nfi.o
 endif
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
Index: linux-2.6.36/drivers/mtd/chips/spi_controller.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/chips/spi_controller.c	2017-04-22 16:45:21.000000000 +0800
+++ linux-2.6.36/drivers/mtd/chips/spi_controller.c	2017-04-24 17:30:48.698072665 +0800
@@ -45,6 +45,7 @@
 #include <asm/io.h>
 #include <asm/tc3162/tc3162.h>
 #include <asm/types.h>							
+#include <asm/string.h>
 
 /* NAMING CONSTANT DECLARATIONS ------------------------------------------------------ */
 
@@ -73,6 +74,9 @@
 #define _SPI_CONTROLLER_REGS_INTERRUPT				(_SPI_CONTROLLER_REGS_BASE + 0x0090)
 #define _SPI_CONTROLLER_REGS_INTERRUPT_EN			(_SPI_CONTROLLER_REGS_BASE + 0x0094)
 #define _SPI_CONTROLLER_REGS_SI_CK_SEL				(_SPI_CONTROLLER_REGS_BASE + 0x009C)
+#define _SPI_CONTROLLER_REGS_SW_CFGNANDADDR_VAL		(_SPI_CONTROLLER_REGS_BASE + 0x010C)
+#define _SPI_CONTROLLER_REGS_SW_CFGNANDADDR_EN		(_SPI_CONTROLLER_REGS_BASE + 0x0110)
+#define _SPI_CONTROLLER_REGS_NFI2SPI_EN				(_SPI_CONTROLLER_REGS_BASE + 0x0130)
 
 /* Register Value Definition */
 #define	_SPI_CONTROLLER_VAL_OP_CSH					(0x00)
@@ -111,6 +115,10 @@
 #define _SPI_CONTROLLER_VAL_MANUAL_MTXMODE			(0x9)
 #define _SPI_CONTROLLER_VAL_MANUAL_MANUALEN			(0x1)
 #define _SPI_CONTROLLER_VAL_DDATA_ENABLE			(0x1)
+#define _SPI_CONTROLLER_VAL_AUTO_MTXMODE			(0x0)
+#define _SPI_CONTROLLER_VAL_MANUAL_MANUALDISABLE	(0x0)
+#define _SPI_CONTROLLER_VAL_NFI2SPI_ENABLE			(1)
+#define _SPI_CONTROLLER_VAL_NFI2SPI_DISABLE			(0)
 
 
 #define _SPI_CONTROLLER_CHECK_TIMES					(10000)
@@ -125,13 +133,17 @@
 #define	ReadReg(reg)								(VPint(reg))
 #define	bReadReg(reg, mask)							(VPint(reg) & mask)
 
-//#define _SPI_CONTROLLER_DEBUG_PRINTF				prom_printf
-#define _SPI_CONTROLLER_DEBUG_PRINTF				
+#define _SPI_CONTROLLER_PRINTF						printk
+#define _SPI_CONTROLLER_DEBUG_PRINTF				spi_controller_debug_printf	
 #define _SPI_CONTROLLER_DEBUG_PRINTF_ARRAY			spi_controller_debug_printf_array
+#define _SPI_CONTROLLER_GET_CONF_PTR				&(_spi_controller_conf_t)
+#define _SPI_CONTROLLER_MEMCPY						memcpy
 
 /* TYPE DECLARATIONS ----------------------------------------------------------------- */
 
 /* STATIC VARIABLE DECLARATIONS ------------------------------------------------------ */
+u8		_SPI_CONTROLLER_DEBUG_FLAG= 0;	/* For control printf debug message or not */
+SPI_CONTROLLER_CONF_T	_spi_controller_conf_t;
 
 /* LOCAL SUBPROGRAM BODIES------------------------------------------------------------ */
 void spi_controller_debug_printf_array (u8 *ptr_data, u32 len)
@@ -145,6 +157,21 @@
 	}
 #endif	
 }
+static void spi_controller_debug_printf( char *fmt, ... )
+{
+	if( _SPI_CONTROLLER_DEBUG_FLAG == 1 )
+	{
+		unsigned char 		str_buf[100];	
+		va_list 			argptr;
+		int 				cnt;		
+	
+		va_start(argptr, fmt);
+		cnt = vsprintf(str_buf, fmt, argptr);
+		va_end(argptr);
+				
+		prom_printf("%s", str_buf);	
+	}
+}
 
 /*------------------------------------------------------------------------------------
  * FUNCTION: static SPI_CONTROLLER_RTN_T spi_controller_set_opfifo( u8  op_cmd,
@@ -254,7 +281,7 @@
 	u32						idx;
 	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
 	
-	_SPI_CONTROLLER_DEBUG_PRINTF("spi_controller_write_data_fifo : len=0x%x, data: ", data_len);
+	_SPI_CONTROLLER_DEBUG_PRINTF("spi_controller_write_data_fifo : len=0x%x, data: 0x%x\n", data_len, *ptr_data);
 	_SPI_CONTROLLER_DEBUG_PRINTF_ARRAY(ptr_data, data_len);
 	
 	for( idx =0 ; idx<data_len ; idx++)
@@ -278,6 +305,87 @@
 }
 
 /* EXPORTED SUBPROGRAM BODIES -------------------------------------------------------- */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Set_Configure( SPI_CONTROLLER_CONF_T *ptr_spi_controller_conf_t )
+{
+	SPI_CONTROLLER_CONF_T	*ptr_spi_conf_t;
+
+	ptr_spi_conf_t = _SPI_CONTROLLER_GET_CONF_PTR;
+
+	/* Store new setting */
+	_SPI_CONTROLLER_MEMCPY(ptr_spi_conf_t, ptr_spi_controller_conf_t, sizeof(SPI_CONTROLLER_CONF_T) );	
+
+	/* Setting Mode */	
+	if( (ptr_spi_conf_t->mode) == SPI_CONTROLLER_MODE_AUTO )		
+	{
+		_SPI_CONTROLLER_DEBUG_PRINTF("SPI_CONTROLLER_Set_Configure: AUTO Mode\n");
+		/* Switch out DMA circuit  */
+		if(isEN7526c) {
+			WriteReg( _SPI_CONTROLLER_REGS_NFI2SPI_EN, _SPI_CONTROLLER_VAL_NFI2SPI_DISABLE);
+		}
+		/* manaul mode -> auto mode */
+		/*Set 0  to SF_MTX_MODE_TOG */		
+		WriteReg( _SPI_CONTROLLER_REGS_MTX_MODE_TOG, _SPI_CONTROLLER_VAL_AUTO_MTXMODE);
+		
+		/*Enable Auto Mode */
+		WriteReg( _SPI_CONTROLLER_REGS_MANUAL_EN, _SPI_CONTROLLER_VAL_MANUAL_MANUALDISABLE);					
+	}
+	if( (ptr_spi_conf_t->mode) == SPI_CONTROLLER_MODE_MANUAL)
+	{
+		_SPI_CONTROLLER_DEBUG_PRINTF("SPI_CONTROLLER_Set_Configure: Manual Mode\n");
+
+		/* Switch out DMA circuit  */
+		if(isEN7526c) {
+			WriteReg( _SPI_CONTROLLER_REGS_NFI2SPI_EN, _SPI_CONTROLLER_VAL_NFI2SPI_DISABLE);
+		}
+		/* disable read_idle_enable */
+		WriteReg( _SPI_CONTROLLER_REGS_READ_IDLE_EN , _SPI_CONTROLLER_VAL_READ_IDLE_DISABLE);
+		
+		/*wait until auto read status is IDLE */
+		while(ReadReg( _SPI_CONTROLLER_REGS_RDCTL_FSM ));
+		
+		/*auto mode -> manaul mode */
+		/*Set 9  to SF_MTX_MODE_TOG */
+		WriteReg( _SPI_CONTROLLER_REGS_MTX_MODE_TOG, _SPI_CONTROLLER_VAL_MANUAL_MTXMODE);
+		
+		/*Enable Manual Mode */
+		WriteReg( _SPI_CONTROLLER_REGS_MANUAL_EN, _SPI_CONTROLLER_VAL_MANUAL_MANUALEN);
+	}
+	if( (ptr_spi_conf_t->mode) == SPI_CONTROLLER_MODE_DMA)
+	{
+		_SPI_CONTROLLER_DEBUG_PRINTF("SPI_CONTROLLER_Set_Configure: DMA Mode\n");
+	
+		/* Switch into DMA circuit  */
+		if(isEN7526c) {
+			WriteReg( _SPI_CONTROLLER_REGS_NFI2SPI_EN, _SPI_CONTROLLER_VAL_NFI2SPI_ENABLE);
+		}
+
+		/* manaul mode -> auto mode */
+		/*Set 0  to SF_MTX_MODE_TOG */
+		WriteReg( _SPI_CONTROLLER_REGS_MTX_MODE_TOG, _SPI_CONTROLLER_VAL_AUTO_MTXMODE);
+		
+		/*Enable Auto Mode */
+		WriteReg( _SPI_CONTROLLER_REGS_MANUAL_EN, _SPI_CONTROLLER_VAL_MANUAL_MANUALDISABLE);
+
+	}
+
+	/* Set dummy byte number */
+	WriteReg(_SPI_CONTROLLER_REGS_DUMMY, (ptr_spi_conf_t->dummy_byte_num) );	
+
+	return (SPI_CONTROLLER_RTN_NO_ERROR);	
+}
+
+
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Get_Configure( SPI_CONTROLLER_CONF_T *ptr_rtn_spi_controller_conf_t )
+{
+
+	SPI_CONTROLLER_CONF_T	*ptr_spi_controller_conf_info_t;
+
+	ptr_spi_controller_conf_info_t = _SPI_CONTROLLER_GET_CONF_PTR;
+	_SPI_CONTROLLER_MEMCPY( ptr_rtn_spi_controller_conf_t, ptr_spi_controller_conf_info_t, sizeof(SPI_CONTROLLER_CONF_T) );
+
+	return (SPI_CONTROLLER_RTN_NO_ERROR);
+}
+
 /*------------------------------------------------------------------------------------
  * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void )
  * PURPOSE : To provide interface for enable SPI Controller Manual Mode Enable.
@@ -299,19 +407,12 @@
 SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void )
 {	
 	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
-	
-	/* disable read_idle_enable */
-	WriteReg( _SPI_CONTROLLER_REGS_READ_IDLE_EN , _SPI_CONTROLLER_VAL_READ_IDLE_DISABLE);
-	
-	/*wait until auto read status is IDLE */
-	while(ReadReg( _SPI_CONTROLLER_REGS_RDCTL_FSM ));
-	
-	/*auto mode -> manaul mode */
-	/*Set 9  to SF_MTX_MODE_TOG */
-	WriteReg( _SPI_CONTROLLER_REGS_MTX_MODE_TOG, _SPI_CONTROLLER_VAL_MANUAL_MTXMODE);
-	
-	/*Enable Manual Mode */
-	WriteReg( _SPI_CONTROLLER_REGS_MANUAL_EN, _SPI_CONTROLLER_VAL_MANUAL_MANUALEN);
+	SPI_CONTROLLER_CONF_T	spi_conf_t;
+
+	/* Switch to manual mode*/
+	spi_conf_t.dummy_byte_num = 1 ;
+	spi_conf_t.mode = SPI_CONTROLLER_MODE_MANUAL;
+	SPI_CONTROLLER_Set_Configure(&spi_conf_t);
 	
 	return (rtn_status);
 }
@@ -543,4 +644,32 @@
 	
 	return (rtn_status);
 }
+
+void SPI_CONTROLLER_DEBUG_ENABLE( void )
+{	
+	_SPI_CONTROLLER_DEBUG_FLAG = 1;	
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_DEBUG_DISABLE( void )
+ * PURPOSE : To disable to printf debug message of SPI NAND driver.
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_CONTROLLER_DEBUG_DISABLE( void )
+{	
+	_SPI_CONTROLLER_DEBUG_FLAG = 0;	
+}
+
 /* End of [spi_controller.c] package */
Index: linux-2.6.36/drivers/mtd/chips/spi_controller.h
===================================================================
--- linux-2.6.36.orig/drivers/mtd/chips/spi_controller.h	2017-04-22 16:45:21.000000000 +0800
+++ linux-2.6.36/drivers/mtd/chips/spi_controller.h	2017-04-24 17:25:37.290908109 +0800
@@ -67,7 +67,21 @@
 } SPI_CONTROLLER_RTN_T;
 
 
+typedef enum{
+	SPI_CONTROLLER_MODE_AUTO=0,
+	SPI_CONTROLLER_MODE_MANUAL,
+	SPI_CONTROLLER_MODE_DMA,
+	SPI_CONTROLLER_MODE_NO
+} SPI_CONTROLLER_MODE_T;
+
+typedef struct SPI_CONTROLLER_CONFIGURE
+{
+	SPI_CONTROLLER_MODE_T	mode;
+	u32						dummy_byte_num;
+} SPI_CONTROLLER_CONF_T;
 /* EXPORTED SUBPROGRAM SPECIFICATION ------------------------------------------------- */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Set_Configure( SPI_CONTROLLER_CONF_T *ptr_spi_controller_conf_t );
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Get_Configure( SPI_CONTROLLER_CONF_T *ptr_rtn_spi_controller_conf_t );
 
 /*------------------------------------------------------------------------------------
  * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void )
@@ -194,7 +208,26 @@
  */
 SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_High( void );
 
+void SPI_CONTROLLER_DEBUG_ENABLE( void );
 
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_DEBUG_DISABLE( void )
+ * PURPOSE : To disable to printf debug message of SPI NAND driver.
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_CONTROLLER_DEBUG_DISABLE( void );
 #endif /* ifndef __SPI_CONTROLLER_H__ */
 /* End of [spi_controller.h] package */
 
Index: linux-2.6.36/drivers/mtd/chips/spi_ecc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.36/drivers/mtd/chips/spi_ecc.c	2017-04-24 17:21:28.211443190 +0800
@@ -0,0 +1,583 @@
+#include "spi_ecc.h"
+#include <asm/io.h>
+#include <asm/tc3162/tc3162.h>
+#include <stdarg.h>
+#include <asm/string.h>
+
+/* MACRO DECLARATIONS ---------------------------------------------------------------- */
+
+/*******************************************************************************
+ * ECC Register Definition 
+ *******************************************************************************/
+#define _SPI_ECC_REGS_BASE						0xBFA12000
+#define _SPI_ECC_REGS_ECCCON					(_SPI_ECC_REGS_BASE + 0x0000)
+#define _SPI_ECC_REGS_ENCCNFG					(_SPI_ECC_REGS_BASE + 0x0004)
+#define _SPI_ECC_REGS_ENCDIADDR					(_SPI_ECC_REGS_BASE + 0x0008)
+#define _SPI_ECC_REGS_ENCIDLE					(_SPI_ECC_REGS_BASE + 0x000C)
+#define _SPI_ECC_REGS_ENCPAR0					(_SPI_ECC_REGS_BASE + 0x0010)
+#define _SPI_ECC_REGS_ENCPAR1					(_SPI_ECC_REGS_BASE + 0x0014)
+#define _SPI_ECC_REGS_ENCPAR2					(_SPI_ECC_REGS_BASE + 0x0018)
+#define _SPI_ECC_REGS_ENCPAR3					(_SPI_ECC_REGS_BASE + 0x001C)
+#define _SPI_ECC_REGS_ENCPAR4					(_SPI_ECC_REGS_BASE + 0x0020)
+#define _SPI_ECC_REGS_ENCPAR5					(_SPI_ECC_REGS_BASE + 0x0024)
+#define _SPI_ECC_REGS_ENCPAR6					(_SPI_ECC_REGS_BASE + 0x0028)
+#define _SPI_ECC_REGS_ENCSTA					(_SPI_ECC_REGS_BASE + 0x002C)
+#define _SPI_ECC_REGS_ENCIRQEN					(_SPI_ECC_REGS_BASE + 0x0030)
+#define _SPI_ECC_REGS_ENCIRQSTA					(_SPI_ECC_REGS_BASE + 0x0034)
+#define _SPI_ECC_REGS_PIO_DIRDY					(_SPI_ECC_REGS_BASE + 0x0080)
+#define _SPI_ECC_REGS_PIO_DI					(_SPI_ECC_REGS_BASE + 0x0084)
+#define _SPI_ECC_REGS_DECCON					(_SPI_ECC_REGS_BASE + 0x0100)
+#define _SPI_ECC_REGS_DECCNFG					(_SPI_ECC_REGS_BASE + 0x0104)
+#define _SPI_ECC_REGS_DECDIADDR					(_SPI_ECC_REGS_BASE + 0x0108)
+#define _SPI_ECC_REGS_DECIDLE					(_SPI_ECC_REGS_BASE + 0x010C)
+#define _SPI_ECC_REGS_DECFER					(_SPI_ECC_REGS_BASE + 0x0110)
+#define _SPI_ECC_REGS_DECNUM0					(_SPI_ECC_REGS_BASE + 0x0114)
+#define _SPI_ECC_REGS_DECNUM1					(_SPI_ECC_REGS_BASE + 0x0118)
+#define _SPI_ECC_REGS_DECDONE					(_SPI_ECC_REGS_BASE + 0x011C)
+#define _SPI_ECC_REGS_DECEL0					(_SPI_ECC_REGS_BASE + 0x0120)
+#define _SPI_ECC_REGS_DECEL1					(_SPI_ECC_REGS_BASE + 0x0124)
+#define _SPI_ECC_REGS_DECEL2					(_SPI_ECC_REGS_BASE + 0x0128)
+#define _SPI_ECC_REGS_DECEL3					(_SPI_ECC_REGS_BASE + 0x012C)
+#define _SPI_ECC_REGS_DECEL4					(_SPI_ECC_REGS_BASE + 0x0130)
+#define _SPI_ECC_REGS_DECEL5					(_SPI_ECC_REGS_BASE + 0x0134)
+#define _SPI_ECC_REGS_DECEL6					(_SPI_ECC_REGS_BASE + 0x0138)
+#define _SPI_ECC_REGS_DECEL7					(_SPI_ECC_REGS_BASE + 0x013C)
+#define _SPI_ECC_REGS_DECIRQEN					(_SPI_ECC_REGS_BASE + 0x0140)
+#define _SPI_ECC_REGS_DECIRQSTA					(_SPI_ECC_REGS_BASE + 0x0144)
+#define _SPI_ECC_REGS_DECFSM					(_SPI_ECC_REGS_BASE + 0x014C)
+
+
+/*******************************************************************************
+ * ECC Register Field Definition 
+ *******************************************************************************/
+ 
+/* ECC_ENCCON */
+#define _SPI_ECC_REGS_ECCCON_ENABLE				(0x1)
+
+/* ECC_ENCCNFG */
+#define _SPI_ECC_REGS_ENCCNFG_ENCMS_MASK		(0x1FF80000)
+#define _SPI_ECC_REGS_ENCCNFG_ENCMS_SHIFT		(19)
+
+#define _SPI_ECC_REGS_ENCCNFG_ENCMODE_MASK		(0x00000030)
+#define _SPI_ECC_REGS_ENCCNFG_ENCMODE_SHIFT		(4)
+#define _SPI_ECC_REGS_ENCCNFG_ENCMODE_NFIMODE	(0x01)
+
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK		(0x00000007)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT		(0)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_4BITS		(0)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_6BITS		(1)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_8BITS		(2)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_10BITS	(3)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_12BITS	(4)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_14BITS	(5)
+#define _SPI_ECC_REGS_ENCCNFG_ENCTNUM_16BITS	(6)
+
+/* ECC_ENCIDLE */
+#define _SPI_ECC_REGS_ENCIDLE_STAT_PROCESSING	(0)
+#define _SPI_ECC_REGS_ENCIDLE_STAT_IDLE			(1)
+
+/* ECC_ENCODE_IRQEN*/
+#define _SPI_ECC_REGS_ENCIRQEN_IRQEN			(0x1)
+
+/*ECC_ENCODE_IRQSTATUS */
+#define _SPI_ECC_REGS_ENCIRQSTA_PROCESSING		(0)
+#define _SPI_ECC_REGS_ENCIRQSTA_DONE			(1)
+
+
+
+/* ECC_DECCON */
+#define _SPI_ECC_REGS_DECCON_ENABLE				(0x1)
+
+/* ECC_DECCNFG */
+#define _SPI_ECC_REGS_DECCNFG_DECMS_MASK		(0x1FFF0000)
+#define _SPI_ECC_REGS_DECCNFG_DECMS_SHIFT		(16)
+
+#define _SPI_ECC_REGS_DECCNFG_DECCON_MASK		(0x00003000)
+#define _SPI_ECC_REGS_DECCNFG_DECCON_SHIFT		(12)
+#define _SPI_ECC_REGS_DECCNFG_DECCON_VALUE		(0x3)
+
+#define _SPI_ECC_REGS_DECCNFG_DECMODE_MASK		(0x00000030)
+#define _SPI_ECC_REGS_DECCNFG_DECMODE_SHIFT		(4)
+#define _SPI_ECC_REGS_DECCNFG_DECMODE_NFIMODE	(0x01)
+
+#define _SPI_ECC_REGS_DECCNFG_DECEMPTY_MASK		(0x80000000)
+#define _SPI_ECC_REGS_DECCNFG_DECEMPTY_SHIFT	(31)
+#define _SPI_ECC_REGS_DECCNFG_DECEMPTY_VALUE	(0x1)
+
+
+
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK		(0x00000007)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT		(0)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_4BITS		(0)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_6BITS		(1)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_8BITS		(2)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_10BITS	(3)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_12BITS	(4)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_14BITS	(5)
+#define _SPI_ECC_REGS_DECCNFG_DECTNUM_16BITS	(6)
+
+/* ECC_DECIDLE */
+#define _SPI_ECC_REGS_DECIDLE_STAT_PROCESSING	(0)
+#define _SPI_ECC_REGS_DECIDLE_STAT_IDLE			(1)
+
+/* ECC_DECODE_IRQEN*/
+#define _SPI_ECC_REGS_DECIRQEN_IRQEN			(0x1)
+
+/*ECC_DECODE_IRQSTATUS */
+#define _SPI_ECC_REGS_DECIRQSTA_PROCESSING		(0)
+#define _SPI_ECC_REGS_DECIRQSTA_DONE			(1)
+
+
+/* ECC_DECODE NUM0 */
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM0_MASK		(0x1F)
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM0_SHIFT		(0)
+
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM1_MASK		(0x3E0)
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM1_SHIFT		(5)
+
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM2_MASK		(0x7C00)
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM2_SHIFT		(10)
+
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM3_MASK		(0x000F8000)
+#define _SPI_ECC_REGS_DECNUM0_ERRNUM3_SHIFT		(15)
+
+/* ECC_DECODE NUM1 */
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM4_MASK		(0x1F)
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM4_SHIFT		(0)
+
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM5_MASK		(0x3E0)
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM5_SHIFT		(5)
+
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM6_MASK		(0x7C00)
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM6_SHIFT		(10)
+
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM7_MASK		(0x000F8000)
+#define _SPI_ECC_REGS_DECNUM1_ERRNUM7_SHIFT		(15)
+
+#define _SPI_ECC_UNCORRECTABLE_VALUE			(0x1F)
+
+
+#define READ_REGISTER_UINT32(reg) \
+    (*(volatile unsigned int  * const)(reg))
+
+#define WRITE_REGISTER_UINT32(reg, val) \
+    (*(volatile unsigned int  * const)(reg)) = (val)
+
+#define INREG32(x)          READ_REGISTER_UINT32((unsigned int *)((void*)(x)))
+#define OUTREG32(x, y)      WRITE_REGISTER_UINT32((unsigned int *)((void*)(x)), (unsigned int )(y))
+#define SETREG32(x, y)      OUTREG32(x, INREG32(x)|(y))
+#define CLRREG32(x, y)      OUTREG32(x, INREG32(x)&~(y))
+#define MASKREG32(x, y, z)  OUTREG32(x, (INREG32(x)&~(y))|(z))
+
+#define _SPI_ECC_REG8_READ(addr)						INREG32(addr)
+#define _SPI_ECC_REG8_WRITE(addr, data)					OUTREG32(addr, data)
+#define _SPI_ECC_REG8_SETBITS(addr, data)				SETREG32(addr, data)
+#define _SPI_ECC_REG8_CLRBITS(addr, data)				CLRREG32(addr, data)
+#define _SPI_ECC_REG8_SETMASKBITS(addr, mask, data)		MASKREG32(addr, mask, data)
+
+#define _SPI_ECC_REG16_READ(addr)						INREG32(addr)
+#define _SPI_ECC_REG16_WRITE(addr, data)				OUTREG32(addr, data)
+#define _SPI_ECC_REG16_SETBITS(addr, data)				SETREG32(addr, data)
+#define _SPI_ECC_REG16_CLRBITS(addr, data)				CLRREG32(addr, data)
+#define _SPI_ECC_REG16_SETMASKBITS(addr, mask, data)	MASKREG32(addr, mask, data)
+
+#define _SPI_ECC_REG32_READ(addr)						INREG32(addr)
+#define _SPI_ECC_REG32_WRITE(addr, data)				OUTREG32(addr, data)
+#define _SPI_ECC_REG32_SETBITS(addr, data)				SETREG32(addr, data)
+#define _SPI_ECC_REG32_CLRBITS(addr, data)				CLRREG32(addr, data)
+#define _SPI_ECC_REG32_SETMASKBITS(addr, mask, data)	MASKREG32(addr, mask, data)
+
+
+#define _SPI_ECC_GET_ENCODE_INFO_PTR	&(_spi_ecc_encode_conf_info_t)
+#define _SPI_ECC_GET_DECODE_INFO_PTR	&(_spi_ecc_decode_conf_info_t)
+
+#define _SPI_ECC_PRINTF									printk
+#define _SPI_ECC_DEBUG_PRINTF							spi_ecc_debug_printf
+#define _SPI_ECC_MEMCPY									memcpy
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+
+
+/* STATIC VARIABLE DECLARATIONS ------------------------------------------------------ */
+SPI_ECC_ENCODE_CONF_T	_spi_ecc_encode_conf_info_t;
+SPI_ECC_DECODE_CONF_T	_spi_ecc_decode_conf_info_t;
+u8		_SPI_ECC_DEBUG_FLAG = 0;	/* For control printf debug message or not */
+
+/* LOCAL SUBPROGRAM BODIES------------------------------------------------------------ */
+static void spi_ecc_debug_printf( char *fmt, ... )
+{
+	if( _SPI_ECC_DEBUG_FLAG == 1 )
+	{
+		unsigned char 		str_buf[100];	
+		va_list 			argptr;
+		int 				cnt;		
+	
+		va_start(argptr, fmt);
+		cnt = vsprintf(str_buf, fmt, argptr);
+		va_end(argptr);
+				
+		printk("%s", str_buf);	
+	}
+}
+
+/* EXPORTED SUBPROGRAM BODIES -------------------------------------------------------- */
+SPI_ECC_RTN_T SPI_ECC_Regs_Dump( void )
+{
+	u32		idx;
+	
+	for(idx = _SPI_ECC_REGS_BASE ; idx <= _SPI_ECC_REGS_DECFSM ; idx +=4)
+	{
+		_SPI_ECC_PRINTF("reg(0x%x) = 0x%x\n", idx, _SPI_ECC_REG32_READ(idx) );
+	}
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Check_Idle( SPI_ECC_ENCODE_STATUS_T *prt_rtn_encode_status_t )
+{
+	if( _SPI_ECC_REG16_READ(_SPI_ECC_REGS_ENCIDLE) == _SPI_ECC_REGS_ENCIDLE_STAT_PROCESSING )
+	{
+		*prt_rtn_encode_status_t = SPI_ECC_ENCODE_STATUS_PROCESSING ;
+	}
+	if( _SPI_ECC_REG16_READ(_SPI_ECC_REGS_ENCIDLE) == _SPI_ECC_REGS_ENCIDLE_STAT_IDLE )
+	{
+		*prt_rtn_encode_status_t = SPI_ECC_ENCODE_STATUS_IDLE ;
+	}	
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Check_Done( SPI_ECC_ENCODE_STATUS_T *prt_rtn_encode_status_t )
+{
+	if( _SPI_ECC_REG16_READ(_SPI_ECC_REGS_ENCIRQSTA) == _SPI_ECC_REGS_ENCIRQSTA_PROCESSING )
+	{
+		*prt_rtn_encode_status_t = SPI_ECC_ENCODE_STATUS_PROCESSING ;
+	}
+	if( _SPI_ECC_REG16_READ(_SPI_ECC_REGS_ENCIRQSTA) == _SPI_ECC_REGS_ENCIRQSTA_DONE )
+	{
+		*prt_rtn_encode_status_t = SPI_ECC_ENCODE_STATUS_DONE ;
+	}
+	
+	return (SPI_ECC_RTN_NO_ERROR);	
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Get_Configure( SPI_ECC_ENCODE_CONF_T  *ptr_rtn_encode_conf_t )
+{
+	SPI_ECC_ENCODE_CONF_T *  encode_conf_t;
+
+	encode_conf_t = _SPI_ECC_GET_ENCODE_INFO_PTR;
+
+
+	_SPI_ECC_MEMCPY(ptr_rtn_encode_conf_t, encode_conf_t, sizeof(SPI_ECC_ENCODE_CONF_T));
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Set_Configure( SPI_ECC_ENCODE_CONF_T  *ptr_encode_conf_t )
+{
+
+	SPI_ECC_ENCODE_CONF_T  *spi_ecc_encode_info_t;
+			
+	/* Store new setting */ 
+	spi_ecc_encode_info_t = _SPI_ECC_GET_ENCODE_INFO_PTR;
+	_SPI_ECC_MEMCPY(spi_ecc_encode_info_t, ptr_encode_conf_t, sizeof(SPI_ECC_ENCODE_CONF_T));					
+		
+	/* Set Block size */
+	_SPI_ECC_REG32_SETMASKBITS( _SPI_ECC_REGS_ENCCNFG,  _SPI_ECC_REGS_ENCCNFG_ENCMS_MASK,	\
+								(ptr_encode_conf_t-> encode_block_size) << _SPI_ECC_REGS_ENCCNFG_ENCMS_SHIFT );								
+								
+	/* Set ECC Ability */							
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_4BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_4BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_6BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_6BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_8BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_8BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_10BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_10BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_12BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_12BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_14BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_14BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}
+	if( (ptr_encode_conf_t->encode_ecc_abiliry) == SPI_ECC_ENCODE_ABILITY_16BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCTNUM_MASK,	\
+									_SPI_ECC_REGS_ENCCNFG_ENCTNUM_16BITS << _SPI_ECC_REGS_ENCCNFG_ENCTNUM_SHIFT );																		
+	}						
+	
+	return (SPI_ECC_RTN_NO_ERROR);	
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Enable( void)
+{	
+	_SPI_ECC_REG16_SETBITS(_SPI_ECC_REGS_ECCCON, _SPI_ECC_REGS_ECCCON_ENABLE);
+	_SPI_ECC_DEBUG_PRINTF("SPI_ECC_Encode_Set_Configure : encode enable reg(0x%x) = 0x%x\n", _SPI_ECC_REGS_ECCCON, _SPI_ECC_REG16_READ(_SPI_ECC_REGS_ECCCON) );				
+
+	return (SPI_ECC_RTN_NO_ERROR);		
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Disable( void)
+{	
+	_SPI_ECC_REG16_CLRBITS(_SPI_ECC_REGS_ECCCON, _SPI_ECC_REGS_ECCCON_ENABLE);
+	_SPI_ECC_DEBUG_PRINTF("SPI_ECC_Encode_Set_Configure : encode disable reg(0x%x) = 0x%x\n", _SPI_ECC_REGS_ECCCON, _SPI_ECC_REG16_READ(_SPI_ECC_REGS_ECCCON) );		
+	return (SPI_ECC_RTN_NO_ERROR);		
+}
+
+SPI_ECC_RTN_T SPI_ECC_Encode_Init( void )
+{	
+	/* Set Encode Mode as NFI mode */
+	_SPI_ECC_REG32_SETMASKBITS( _SPI_ECC_REGS_ENCCNFG, _SPI_ECC_REGS_ENCCNFG_ENCMODE_MASK,	\
+								_SPI_ECC_REGS_ENCCNFG_ENCMODE_NFIMODE << _SPI_ECC_REGS_ENCCNFG_ENCMODE_SHIFT );
+	
+	/* Enable Encoder IRQ function */
+	_SPI_ECC_REG16_SETBITS( _SPI_ECC_REGS_ENCIRQEN, _SPI_ECC_REGS_ENCIRQEN_IRQEN);	
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+	
+}
+
+/*******************************************************************************************************/
+/*******************************************************************************************************/
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Check_Idle( SPI_ECC_DECODE_STATUS_T *prt_rtn_decode_status_t )
+{
+	if( _SPI_ECC_REG16_READ(_SPI_ECC_REGS_DECIDLE) == _SPI_ECC_REGS_DECIDLE_STAT_PROCESSING )
+	{
+		*prt_rtn_decode_status_t = SPI_ECC_DECODE_STATUS_PROCESSING ;
+	}
+	if( _SPI_ECC_REG16_READ(_SPI_ECC_REGS_DECIDLE) == _SPI_ECC_REGS_DECIDLE_STAT_IDLE )
+	{
+		*prt_rtn_decode_status_t = SPI_ECC_DECODE_STATUS_IDLE ;
+	}	
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+}
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Check_Done( SPI_ECC_DECODE_STATUS_T *prt_rtn_decode_status_t )
+{
+	u32		ret_val = 0;
+
+	ret_val = _SPI_ECC_REG16_READ(_SPI_ECC_REGS_DECIRQSTA);
+
+	if( ret_val != 0 )
+	{
+		_SPI_ECC_DEBUG_PRINTF("SPI_ECC_Decode_Check_Done : decode done, ret_val = 0x%x\n", ret_val);
+		*prt_rtn_decode_status_t = SPI_ECC_DECODE_STATUS_DONE ;
+	}
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+}
+
+SPI_ECC_RTN_T SPI_ECC_DECODE_Check_Correction_Status( void )
+{
+	
+	u32							dec_err_number_reg0;
+	u32							dec_err_number_reg1;
+	SPI_ECC_RTN_T rtn_status =  SPI_ECC_RTN_NO_ERROR;
+	
+	
+	dec_err_number_reg0 = _SPI_ECC_REG32_READ(_SPI_ECC_REGS_DECNUM0);
+	
+	/* Sector 0 can be correctalbe or not */
+	if( ((dec_err_number_reg0 & _SPI_ECC_REGS_DECNUM0_ERRNUM0_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM0_ERRNUM0_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 0 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}
+
+	/* Sector 1 can be correctalbe or not */
+	if( ((dec_err_number_reg0 & _SPI_ECC_REGS_DECNUM0_ERRNUM1_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM0_ERRNUM1_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 1 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}	
+	
+	/* Sector 2 can be correctalbe or not */
+	if( ((dec_err_number_reg0 & _SPI_ECC_REGS_DECNUM0_ERRNUM2_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM0_ERRNUM2_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 2 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}		
+	
+	/* Sector 3 can be correctalbe or not */
+	if( ((dec_err_number_reg0 & _SPI_ECC_REGS_DECNUM0_ERRNUM3_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM0_ERRNUM3_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 3 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}			
+	
+	
+	dec_err_number_reg1 = _SPI_ECC_REG32_READ(_SPI_ECC_REGS_DECNUM1);
+	
+	/* Sector 4 can be correctalbe or not */
+	if( ((dec_err_number_reg1 & _SPI_ECC_REGS_DECNUM1_ERRNUM4_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM1_ERRNUM4_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 4 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}				
+	/* Sector 5 can be correctalbe or not */
+	if( ((dec_err_number_reg1 & _SPI_ECC_REGS_DECNUM1_ERRNUM5_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM1_ERRNUM5_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 5 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}
+	/* Sector 6 can be correctalbe or not */
+	if( ((dec_err_number_reg1 & _SPI_ECC_REGS_DECNUM1_ERRNUM6_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM1_ERRNUM6_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 6 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}	
+	/* Sector 7 can be correctalbe or not */
+	if( ((dec_err_number_reg1 & _SPI_ECC_REGS_DECNUM1_ERRNUM7_MASK )  \
+			>> _SPI_ECC_REGS_DECNUM1_ERRNUM7_SHIFT) ==  _SPI_ECC_UNCORRECTABLE_VALUE )
+	{
+			_SPI_ECC_PRINTF("SPI_ECC_DECODE_Check_Correction_Status : sector 7 uncorrectable.\n");
+			rtn_status = SPI_ECC_RTN_CORRECTION_ERROR;
+	}			
+	
+	return ( rtn_status );
+	
+}
+
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Get_Configure( SPI_ECC_DECODE_CONF_T  *ptr_rtn_decode_conf_t )
+{
+	SPI_ECC_DECODE_CONF_T  *decode_conf_t;
+
+	decode_conf_t = _SPI_ECC_GET_DECODE_INFO_PTR;
+
+
+	_SPI_ECC_MEMCPY(ptr_rtn_decode_conf_t, decode_conf_t, sizeof(SPI_ECC_DECODE_CONF_T));
+
+	
+	return (SPI_ECC_RTN_NO_ERROR);
+}
+
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Set_Configure( SPI_ECC_DECODE_CONF_T  *ptr_decode_conf_t )
+{
+
+	SPI_ECC_DECODE_CONF_T  *spi_ecc_decode_info_t;
+			
+	/* Store new setting */ 
+	spi_ecc_decode_info_t = _SPI_ECC_GET_DECODE_INFO_PTR;
+	_SPI_ECC_MEMCPY(spi_ecc_decode_info_t, ptr_decode_conf_t, sizeof(SPI_ECC_DECODE_CONF_T));			
+	
+		
+	/* Set Block size */
+	_SPI_ECC_REG32_SETMASKBITS( _SPI_ECC_REGS_DECCNFG,  _SPI_ECC_REGS_DECCNFG_DECMS_MASK,	\
+								(ptr_decode_conf_t-> decode_block_size) << _SPI_ECC_REGS_DECCNFG_DECMS_SHIFT );								
+								
+	/* Set ECC Ability */							
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_4BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_4BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_6BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_6BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_8BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_8BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_10BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_10BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_12BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_12BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_14BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_14BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}
+	if( (ptr_decode_conf_t->decode_ecc_abiliry) == SPI_ECC_DECODE_ABILITY_16BITS )
+	{
+		_SPI_ECC_REG32_SETMASKBITS(_SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECTNUM_MASK,	\
+									_SPI_ECC_REGS_DECCNFG_DECTNUM_16BITS << _SPI_ECC_REGS_DECCNFG_DECTNUM_SHIFT );																		
+	}						
+	
+	return (SPI_ECC_RTN_NO_ERROR);	
+}
+
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Enable( void)
+{
+	_SPI_ECC_REG16_SETBITS(_SPI_ECC_REGS_DECCON, _SPI_ECC_REGS_DECCON_ENABLE);
+	return (SPI_ECC_RTN_NO_ERROR);	
+}
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Disable( void)
+{
+	_SPI_ECC_REG16_CLRBITS(_SPI_ECC_REGS_DECCON, _SPI_ECC_REGS_DECCON_ENABLE);
+	return (SPI_ECC_RTN_NO_ERROR);	
+}
+
+
+SPI_ECC_RTN_T SPI_ECC_Decode_Init( void )
+{
+
+	/* Set Decode Mode as NFI mode */
+	_SPI_ECC_REG32_SETMASKBITS( _SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECMODE_MASK,	\
+								_SPI_ECC_REGS_DECCNFG_DECMODE_NFIMODE << _SPI_ECC_REGS_DECCNFG_DECMODE_SHIFT );	
+
+	/* Set Decode Mode have igore empty data function */
+	_SPI_ECC_REG32_SETMASKBITS( _SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECEMPTY_MASK,	\
+								_SPI_ECC_REGS_DECCNFG_DECEMPTY_VALUE << _SPI_ECC_REGS_DECCNFG_DECEMPTY_SHIFT );	
+
+	
+	/* Set Decode has most poweful ability */
+	_SPI_ECC_REG32_SETMASKBITS( _SPI_ECC_REGS_DECCNFG, _SPI_ECC_REGS_DECCNFG_DECCON_MASK,	\
+								_SPI_ECC_REGS_DECCNFG_DECCON_VALUE << _SPI_ECC_REGS_DECCNFG_DECCON_SHIFT );		
+									
+	/* Enable Decoder IRQ function */
+	_SPI_ECC_REG16_SETBITS( _SPI_ECC_REGS_DECIRQEN, _SPI_ECC_REGS_DECIRQEN_IRQEN);		
+								
+								
+	return (SPI_ECC_RTN_NO_ERROR);	
+}
+
+void SPI_ECC_DEBUG_ENABLE( void )
+{	
+	_SPI_ECC_DEBUG_FLAG = 1;	
+}
+
+void SPI_ECC_DEBUG_DISABLE( void )
+{	
+	_SPI_ECC_DEBUG_FLAG = 0;	
+}
+
+
Index: linux-2.6.36/drivers/mtd/chips/spi_ecc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.36/drivers/mtd/chips/spi_ecc.h	2017-04-24 17:21:28.211443190 +0800
@@ -0,0 +1,105 @@
+
+#include <asm/types.h>
+
+typedef enum
+{
+	SPI_ECC_ENCODE_DISABLE=0,
+	SPI_ECC_ENCODE_ENABLE
+} SPI_ECC_ENCODE_T;
+
+typedef enum
+{
+	SPI_ECC_ENCODE_ABILITY_4BITS = 4,
+	SPI_ECC_ENCODE_ABILITY_6BITS = 6,
+	SPI_ECC_ENCODE_ABILITY_8BITS = 8,
+	SPI_ECC_ENCODE_ABILITY_10BITS = 10,
+	SPI_ECC_ENCODE_ABILITY_12BITS = 12,
+	SPI_ECC_ENCODE_ABILITY_14BITS = 14,
+	SPI_ECC_ENCODE_ABILITY_16BITS = 16,
+} SPI_ECC_ENCODE_ABILITY_T;
+
+typedef enum
+{
+	SPI_ECC_ENCODE_STATUS_IDLE=0,
+	SPI_ECC_ENCODE_STATUS_PROCESSING,
+	SPI_ECC_ENCODE_STATUS_DONE,
+} SPI_ECC_ENCODE_STATUS_T;
+
+
+typedef struct SPI_ECC_ENCODE_CONF
+{
+	SPI_ECC_ENCODE_T 			encode_en; 				/* enable encode or not */
+	u32							encode_block_size;		/* encode block size */
+	SPI_ECC_ENCODE_ABILITY_T	encode_ecc_abiliry;		/* Indicate the ECC correction abiliry */
+		
+} SPI_ECC_ENCODE_CONF_T;
+
+
+typedef enum
+{
+	SPI_ECC_DECODE_DISABLE=0,
+	SPI_ECC_DECODE_ENABLE
+} SPI_ECC_DECODE_T;
+
+typedef enum
+{
+	SPI_ECC_DECODE_ABILITY_4BITS = 4,
+	SPI_ECC_DECODE_ABILITY_6BITS = 6,
+	SPI_ECC_DECODE_ABILITY_8BITS = 8,
+	SPI_ECC_DECODE_ABILITY_10BITS = 10,
+	SPI_ECC_DECODE_ABILITY_12BITS = 12,
+	SPI_ECC_DECODE_ABILITY_14BITS = 14,
+	SPI_ECC_DECODE_ABILITY_16BITS = 16,
+} SPI_ECC_DECODE_ABILITY_T;
+
+
+typedef struct SPI_ECC_DECODE_CONF
+{
+	SPI_ECC_DECODE_T 			decode_en; 				/* enable decode or not */
+	u32							decode_block_size;		/* decode block size */
+	SPI_ECC_DECODE_ABILITY_T	decode_ecc_abiliry;		/* Indicate the ECC correction abiliry */
+		
+} SPI_ECC_DECODE_CONF_T;
+
+
+typedef enum
+{
+	SPI_ECC_DECODE_STATUS_IDLE=0,
+	SPI_ECC_DECODE_STATUS_PROCESSING,
+	SPI_ECC_DECODE_STATUS_DONE,
+	SPI_ECC_DECODE_STATUS_TIMEOUT
+} SPI_ECC_DECODE_STATUS_T;
+
+typedef enum
+{
+	SPI_ECC_DECODE_CORRECTION_FAIL=0,
+	SPI_ECC_DECODE_CORRECTION_OK,
+	
+} SPI_ECC_DECODE_CORRECTION_T;
+
+
+typedef enum{
+	SPI_ECC_RTN_NO_ERROR =0,
+	SPI_ECC_RTN_CORRECTION_ERROR,
+
+	SPI_ECC_RTN_DEF_NO
+} SPI_ECC_RTN_T;
+
+SPI_ECC_RTN_T SPI_ECC_Regs_Dump( void );
+SPI_ECC_RTN_T SPI_ECC_Encode_Check_Idle( SPI_ECC_ENCODE_STATUS_T *prt_rtn_encode_status_t );
+SPI_ECC_RTN_T SPI_ECC_Encode_Check_Done( SPI_ECC_ENCODE_STATUS_T *prt_rtn_encode_status_t );
+SPI_ECC_RTN_T SPI_ECC_Encode_Get_Configure( SPI_ECC_ENCODE_CONF_T  *ptr_rtn_encode_conf_t );
+SPI_ECC_RTN_T SPI_ECC_Encode_Set_Configure( SPI_ECC_ENCODE_CONF_T  *ptr_encode_conf_t );
+SPI_ECC_RTN_T SPI_ECC_Encode_Enable( void);
+SPI_ECC_RTN_T SPI_ECC_Encode_Disable( void);
+SPI_ECC_RTN_T SPI_ECC_Encode_Init( void );
+SPI_ECC_RTN_T SPI_ECC_Decode_Check_Idle( SPI_ECC_DECODE_STATUS_T *prt_rtn_decode_status_t );
+SPI_ECC_RTN_T SPI_ECC_Decode_Check_Done( SPI_ECC_DECODE_STATUS_T *prt_rtn_decode_status_t );
+SPI_ECC_RTN_T SPI_ECC_DECODE_Check_Correction_Status( void );
+SPI_ECC_RTN_T SPI_ECC_Decode_Get_Configure( SPI_ECC_DECODE_CONF_T  *ptr_rtn_decode_conf_t );
+SPI_ECC_RTN_T SPI_ECC_Decode_Set_Configure( SPI_ECC_DECODE_CONF_T  *ptr_decode_conf_t );
+SPI_ECC_RTN_T SPI_ECC_Decode_Enable( void);
+SPI_ECC_RTN_T SPI_ECC_Decode_Disable( void);
+SPI_ECC_RTN_T SPI_ECC_Decode_Init( void );
+void SPI_ECC_DEBUG_ENABLE( void );
+void SPI_ECC_DEBUG_DISABLE( void );
\ No newline at end of file
Index: linux-2.6.36/drivers/mtd/chips/spi_nand_flash.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/chips/spi_nand_flash.c	2017-04-24 16:46:36.252181190 +0800
+++ linux-2.6.36/drivers/mtd/chips/spi_nand_flash.c	2017-04-24 17:31:24.044497191 +0800
@@ -55,8 +55,10 @@
 #include <asm/io.h>
 #include <asm/tc3162/tc3162.h>
 #include <stdarg.h>
+#include <asm/string.h>
 
-
+#include "spi_nfi.h"
+#include "spi_ecc.h"
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -84,6 +86,7 @@
 #include <linux/miscdevice.h>
 #include <linux/scatterlist.h>
 
+#include <linux/kthread.h>
 
 #include "../ralink/bmt.h"
 
@@ -146,6 +149,8 @@
 #define _SPI_NAND_ADDR_PROTECTION			0xA0	/* Address of protection */
 #define _SPI_NAND_ADDR_FEATURE				0xB0	/* Address of feature */
 #define _SPI_NAND_ADDR_STATUS				0xC0	/* Address of status */
+#define _SPI_NAND_ADDR_FEATURE_4			0xD0	/* Address of status 4 */
+#define _SPI_NAND_ADDR_STATUS_5				0xE0	/* Address of status 5 */
 #define _SPI_NAND_ADDR_MANUFACTURE_ID		0x00	/* Address of Manufacture ID */
 #define _SPI_NAND_ADDR_DEVICE_ID			0x01	/* Address of Device ID */
 
@@ -159,11 +164,15 @@
 
 
 /* SPI NAND Size Define */
+#define _SPI_NAND_PAGE_SIZE_512				0x0200
 #define _SPI_NAND_PAGE_SIZE_2KBYTE			0x0800	
+#define _SPI_NAND_PAGE_SIZE_4KBYTE			0x1000
 #define _SPI_NAND_OOB_SIZE_64BYTE			0x40
 #define _SPI_NAND_OOB_SIZE_120BYTE			0x78
 #define _SPI_NAND_OOB_SIZE_128BYTE			0x80
+#define _SPI_NAND_OOB_SIZE_256BYTE			0x100
 #define _SPI_NAND_BLOCK_SIZE_128KBYTE		0x20000
+#define _SPI_NAND_BLOCK_SIZE_256KBYTE		0x40000
 #define _SPI_NAND_CHIP_SIZE_512MBIT			0x04000000
 #define _SPI_NAND_CHIP_SIZE_1GBIT			0x08000000
 #define _SPI_NAND_CHIP_SIZE_2GBIT			0x10000000
@@ -178,8 +187,7 @@
 #define _SPI_NAND_MANUFACTURER_ID_ETRON			0xD5
 #define _SPI_NAND_MANUFACTURER_ID_TOSHIBA		0x98
 #define _SPI_NAND_MANUFACTURER_ID_MICRON		0x2C
-
-
+#define _SPI_NAND_MANUFACTURER_ID_HEYANG		0xC9
 
 
 /* SPI NAND Device ID */
@@ -188,6 +196,8 @@
 #define _SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG	0xB1
 #define _SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG	0xD2
 #define _SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG	0xB2
+#define _SPI_NAND_DEVICE_ID_GD5F4GQ4UBYIG	0xD4
+#define _SPI_NAND_DEVICE_ID_GD5F4GQ4UCYIG	0xB4
 #define _SPI_NAND_DEVICE_ID_F50L512M41A		0x20
 #define _SPI_NAND_DEVICE_ID_F50L1G41A0		0x21
 #define _SPI_NAND_DEVICE_ID_W25N01GV		0xAA
@@ -198,11 +208,17 @@
 #define _SPI_NAND_DEVICE_ID_A5U12A21ASC		0x20
 #define _SPI_NAND_DEVICE_ID_A5U1GA21BWS		0x21
 #define _SPI_NAND_DEVICE_ID_EM73C044SNB		0x11
+#define _SPI_NAND_DEVICE_ID_EM73C044SNA		0x19
 #define _SPI_NAND_DEVICE_ID_EM73D044SNA		0x12
+#define _SPI_NAND_DEVICE_ID_EM73E044SNA		0x03
 #define _SPI_NAND_DEVICE_ID_TC58CVG0S3H		0xC2
 #define _SPI_NAND_DEVICE_ID_TC58CVG1S3H		0xCB
+#define _SPI_NAND_DEVICE_ID_TC58CVG2S0H		0xCD
 #define _SPI_NAND_DEVICE_ID_MT29F1G01		0x14
-
+#define _SPI_NAND_DEVICE_ID_MT29F2G01		0x24
+#define _SPI_NAND_DEVICE_ID_MT29F4G01		0x36
+#define _SPI_NAND_DEVICE_ID_HYF1GQ4UAACAE	0x51
+#define _SPI_NAND_DEVICE_ID_HYF2GQ4UAACAE	0x52
 
 
 
@@ -213,8 +229,8 @@
 #define _SPI_NAND_LEN_THREE_BYTE			(3)
 #define _SPI_NAND_BLOCK_ROW_ADDRESS_OFFSET	(6)
 
-#define _SPI_NAND_PAGE_SIZE  				2048
-#define _SPI_NAND_OOB_SIZE  				128
+#define _SPI_NAND_PAGE_SIZE  				4096
+#define _SPI_NAND_OOB_SIZE  				256
 #define _SPI_NAND_CACHE_SIZE 				(_SPI_NAND_PAGE_SIZE+_SPI_NAND_OOB_SIZE)
 
 #define _SPI_FREQUENCY_ADJUST_REG			0xBFA200CC
@@ -223,9 +239,15 @@
 #define MAX_LINUX_USE_OOB_SIZE			26
 #define MAX_USE_OOB_SIZE				(LINUX_USE_OOB_START_OFFSET + MAX_LINUX_USE_OOB_SIZE + 2)
 
+#define EMPTY_DATA						(0)
+#define NONE_EMPTY_DATA					(1)
+#define EMPTY_OOB						(0)
+#define NONE_EMPTY_OOB					(1)
 
 #define MIN(a,b)        ((a) < (b) ? (a) : (b))
 
+#define K0_TO_K1(x)			(((uint32)x) | 0xa0000000)
+#define K1_TO_PHY(x)		(((uint32)x) & 0x1fffffff)
 
 /* MACRO DECLARATIONS ---------------------------------------------------------------- */
 #define _SPI_NAND_BLOCK_ALIGNED_CHECK( __addr__,__block_size__) ((__addr__) & ( __block_size__ - 1))
@@ -255,8 +277,19 @@
 unsigned char _plane_select_bit=0;
 unsigned char _die_id = 0;
 
+#define _SPI_NFI_CHECK_ECC_DONE_MAX_TIMES	(1000000)
+#define CACHE_LINE_SIZE						(32)
+u8	*dma_read_page;
+u8 	tmp_dma_read_page[_SPI_NAND_CACHE_SIZE + CACHE_LINE_SIZE];
+u8	*dma_write_page;
+u8	tmp_dma_write_page[_SPI_NAND_CACHE_SIZE + CACHE_LINE_SIZE];
+
+unsigned long read_times =0;
+unsigned char _ondie_ecc_flag=1;    /* Ondie ECC : [ToDo :  Init this flag base on diffrent chip ?] */
+unsigned char _spi_dma_mode=0;
 struct mtd_info 	*spi_nand_mtd;
 
+#define IOMUX_CONTROL1      (0xBFA20104)
 
 /* TYPE DECLARATIONS ----------------------------------------------------------------- */
 struct _SPI_NAND_FLASH_ID_T {
@@ -264,6 +297,11 @@
 	u8 dev_id;	
 };
 
+struct _SPI_NAND_FLASH_RW_TEST_T {
+	u32 times;
+	u32 block_idx;
+};
+
 /* STATIC VARIABLE DECLARATIONS ------------------------------------------------------ */
 #if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
 
@@ -272,6 +310,7 @@
 static init_bbt_struct *g_bbt = NULL;
 #endif
 
+static struct _SPI_NAND_FLASH_RW_TEST_T rw_test_param;
 
 SPI_NAND_FLASH_DEBUG_LEVEL_T  _SPI_NAND_DEBUG_LEVEL = SPI_NAND_FLASH_DEBUG_LEVEL_0;
 int							  _SPI_NAND_TEST_FLAG = 0;
@@ -310,14 +349,14 @@
 	.oobfree = {{0,12}, {16,12}, {32,12}, {48,12} }
 };
 
-struct spi_nand_flash_ooblayout ooblayout_gigadevice_b = {
+struct spi_nand_flash_ooblayout ooblayout_gigadevice_128 = {
 	.oobsize = 64, 
 	.oobfree = {{0,64}}
 };
 
-struct spi_nand_flash_ooblayout ooblayout_gigadevice_c = {
-	.oobsize = 64, 
-	.oobfree = {{0,64}}
+struct spi_nand_flash_ooblayout ooblayout_gigadevice_256 = {
+	.oobsize = 128,
+	.oobfree = {{0,128}}
 };
 
 struct spi_nand_flash_ooblayout ooblayout_zentel = {
@@ -325,25 +364,59 @@
 	.oobfree = {{0,1}, {8,8}, {16,1}, {24,8}, {32,1}, {40,8}, {48,1}, {56,8} }
 };
 
-struct spi_nand_flash_ooblayout ooblayout_etron = {
-	.oobsize = 60, 
+struct spi_nand_flash_ooblayout ooblayout_etron_73C044SNB = {
+	.oobsize = 64,
 	.oobfree = {{0,16}, {30,16}, {60,16}, {90,16}}
 };
 
-struct spi_nand_flash_ooblayout ooblayout_toshiba = {
+struct spi_nand_flash_ooblayout ooblayout_etron_73D044SNA = {
+	.oobsize = 72,
+	.oobfree = {{0,18}, {32,18}, {64,18}, {96,18}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_etron_73E044SNA = {
+	.oobsize = 144,
+	.oobfree = {{0,18}, {32,18}, {64,18}, {96,18}, {128,18}, {160,18}, {192,18}, {224,18}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_toshiba_128 = {
 	.oobsize = 64, 
 	.oobfree = {{0,64}}
 };
 
+struct spi_nand_flash_ooblayout ooblayout_toshiba_256 = {
+	.oobsize = 128,
+	.oobfree = {{0,128}}
+};
+
 struct spi_nand_flash_ooblayout ooblayout_micron = {
 	.oobsize = 64, 
 	.oobfree = {{0,64}}
 };
 
+struct spi_nand_flash_ooblayout ooblayout_heyang = {
+	.oobsize = 32,
+	.oobfree = {{0,8}, {32,8}, {64,8}, {96,8}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_spi_controller_ecc_64 = {
+	.oobsize = 32,
+	.oobfree = {{0,8}, {16,8}, {32,8}, {48,8}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_spi_controller_ecc_128 = {
+	.oobsize = 96,
+	.oobfree = {{0,8}, {16,8}, {32,8}, {48,8}, {64,64}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_spi_controller_ecc_256 = {
+	.oobsize = 224,
+	.oobfree = {{0,8}, {16,8}, {32,8}, {48,8}, {64,192}}
+};
 
 
 /*****************************[ Notice]******************************/
-/* If new spi nand chip have page size more than 2KB,  or oob size more than 128 bytes,  than*/
+/* If new spi nand chip have page size more than 4KB,  or oob size more than 256 bytes,  than*/
 /* it will need to adjust the #define of _SPI_NAND_PAGE_SIZE and _SPI_NAND_OOB_SIZE */
 /*****************************[ Notice]******************************/
 
@@ -358,6 +431,7 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_gigadevice_a,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
@@ -372,7 +446,8 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
-		oob_free_layout : 			&ooblayout_gigadevice_b,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_128,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
 
@@ -386,7 +461,8 @@
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
-		oob_free_layout : 			&ooblayout_gigadevice_c,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_128,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
 
@@ -400,7 +476,8 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
-		oob_free_layout : 			&ooblayout_gigadevice_b,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_128,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},		
 	
@@ -414,9 +491,40 @@
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
-		oob_free_layout : 			&ooblayout_gigadevice_c,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_128,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},		
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id:						_SPI_NAND_DEVICE_ID_GD5F4GQ4UBYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F4GQ4UB",
+		device_size:				_SPI_NAND_CHIP_SIZE_4GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_4KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_256BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_256KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_256,
+		feature:					SPI_NAND_FLASH_FEATURE_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id:						_SPI_NAND_DEVICE_ID_GD5F4GQ4UCYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F4GQ4UC",
+		device_size:				_SPI_NAND_CHIP_SIZE_4GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_4KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_256BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_256KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_256,
+		feature:					SPI_NAND_FLASH_FEATURE_NONE,
+	},
 				
 	{
 		mfr_id:						_SPI_NAND_MANUFACTURER_ID_ESMT,
@@ -428,6 +536,7 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_esmt,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
@@ -442,6 +551,7 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_esmt,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
@@ -456,6 +566,7 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_winbond,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
@@ -470,8 +581,9 @@
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_winbond,
-		feature:					SPI_NAND_FLASH_DIE_SELECT_HAVE,
+		feature:					SPI_NAND_FLASH_DIE_SELECT_1_HAVE,
 	},		
 	
 	{
@@ -484,6 +596,7 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_mxic,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
@@ -498,6 +611,7 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_mxic,
 		feature:					SPI_NAND_FLASH_PLANE_SELECT_HAVE,
 	},
@@ -512,6 +626,7 @@
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_zentel,		
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
@@ -525,6 +640,7 @@
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout : 			&ooblayout_zentel,		
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},	
@@ -539,7 +655,8 @@
 		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
 		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
-		oob_free_layout : 			&ooblayout_etron,			
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_etron_73C044SNB,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
 	
@@ -552,8 +669,24 @@
 		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
-		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,		
-		oob_free_layout :			&ooblayout_etron,		
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_etron_73D044SNA,
+		feature:					SPI_NAND_FLASH_FEATURE_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_ETRON,
+		dev_id: 					_SPI_NAND_DEVICE_ID_EM73E044SNA,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_EM73E044SNA",
+		device_size:				_SPI_NAND_CHIP_SIZE_4GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_4KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_256BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_256KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_etron_73E044SNA,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},
 	
@@ -566,8 +699,9 @@
 		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
-		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,		
-		oob_free_layout : 			&ooblayout_toshiba,		
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_toshiba_128,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	},		
 
@@ -580,8 +714,24 @@
 		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
-		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,		
-		oob_free_layout : 			&ooblayout_toshiba,		
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_toshiba_128,
+		feature:					SPI_NAND_FLASH_FEATURE_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_TOSHIBA,
+		dev_id: 					_SPI_NAND_DEVICE_ID_TC58CVG2S0H,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_TC58CVG2S0H",
+		device_size:				_SPI_NAND_CHIP_SIZE_4GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_4KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_256KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_toshiba_256,
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
 	}, 
 
@@ -594,11 +744,71 @@
 		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
 		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
 		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
-		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,		
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
 		oob_free_layout :			&ooblayout_micron, 	
 		feature:					SPI_NAND_FLASH_FEATURE_NONE,
-	}	
-	
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_MICRON,
+		dev_id: 					_SPI_NAND_DEVICE_ID_MT29F2G01,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_MT29F2G01",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_micron,
+		feature:					SPI_NAND_FLASH_PLANE_SELECT_HAVE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_MICRON,
+		dev_id: 					_SPI_NAND_DEVICE_ID_MT29F4G01,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_MT29F4G01",
+		device_size:				_SPI_NAND_CHIP_SIZE_4GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_micron,
+		feature:					SPI_NAND_FLASH_PLANE_SELECT_HAVE | SPI_NAND_FLASH_DIE_SELECT_2_HAVE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_HEYANG,
+		dev_id: 					_SPI_NAND_DEVICE_ID_HYF1GQ4UAACAE,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_HYF1GQ4UAACAE",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_heyang,
+		feature:					SPI_NAND_FLASH_FEATURE_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_HEYANG,
+		dev_id: 					_SPI_NAND_DEVICE_ID_HYF2GQ4UAACAE,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_HYF2GQ4UAACAE",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		write_mode:					SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_heyang,
+		feature:					SPI_NAND_FLASH_FEATURE_NONE,
+	},
 };
 
 /* LOCAL SUBPROGRAM BODIES------------------------------------------------------------ */
@@ -669,27 +879,6 @@
 
 }
 
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_die_select( u8 die_id)
-{
-	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-
-	/* 1. Chip Select low */
-	_SPI_NAND_READ_CHIP_SELECT_LOW();
-
-	/* 2. Send C2h opcode (Die Select) */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_DIE_SELECT );
-
-	/* 3. Send Die ID */
-	_SPI_NAND_WRITE_ONE_BYTE( die_id );
-
-	/* 5. Chip Select High */
-	_SPI_NAND_READ_CHIP_SELECT_HIGH();
-
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_die_select\n");
-
-	return (rtn_status);
-}
-
 static SPI_NAND_FLASH_RTN_T spi_nand_protocol_reset( void )
 {
 	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
@@ -920,6 +1109,126 @@
 }
 
 /*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_set_status_reg_4( u8 feature )
+ * PURPOSE : To implement the SPI nand protocol for set status register 4.
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : feature - The feature variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_set_status_reg_4( u8 feature )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Set Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_SET_FEATURE );
+
+	/* 3. Offset addr of feature 4 (0xD0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_FEATURE_4);
+
+	/* 4. Write new proteciton setting */
+	_SPI_NAND_WRITE_ONE_BYTE( feature );
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_set_status_reg_4: feature=0x%x\n", feature);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_4( u8 *ptr_rtn_status )
+ * PURPOSE : To implement the SPI nand protocol for get status register 4.
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: ptr_rtn_status  - A pointer to the ptr_rtn_status variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_4( u8 *ptr_rtn_status )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Get Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_GET_FEATURE );
+
+	/* 3. Offset addr of feature 4 (0xD0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_FEATURE_4);
+
+	/* 4. Read 1 byte data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_status, _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_get_status_reg_4: status=0x%x\n", *ptr_rtn_status);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_5( u8 *ptr_rtn_status )
+ * PURPOSE : To implement the SPI nand protocol for get status register 5.
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: ptr_rtn_status  - A pointer to the ptr_rtn_status variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_5( u8 *ptr_rtn_status )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Get Status) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_GET_FEATURE );
+
+	/* 3. Offset addr of status 5 (0xE0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_STATUS_5);
+
+	/* 4. Read 1 byte data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_status, _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_get_status_reg_5: status=0x%x\n", *ptr_rtn_status);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
  * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_write_enable( void )
  * PURPOSE : To implement the SPI nand protocol for write enable.
  * AUTHOR  : Chuck Kuo
@@ -1158,9 +1467,11 @@
 }
 
 /*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_single_speed( u32  data_offset,
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache( u32  data_offset,
  *                                                                          u32  len,
- *                                                                          u8   *ptr_rtn_buf )
+ *                                                                          u8   *ptr_rtn_buf,
+ *																			u32	 read_mode,
+ *																			SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode)
  * PURPOSE : To implement the SPI nand protocol for read from cache with single speed.
  * AUTHOR  : Chuck Kuo
  * CALLED BY
@@ -1174,14 +1485,14 @@
  * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
  * NOTES   :
  * MODIFICTION HISTORY:
- * Date 2014/12/19 by Chuck Kuo - The first revision for this function.
  *
  *------------------------------------------------------------------------------------
  */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_single_speed( u32 data_offset, 
-																			u32 len, 
-																			u8 *ptr_rtn_buf, 
-																			SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache( u32 data_offset,
+																u32 len,
+																u8 *ptr_rtn_buf,
+																u32 read_mode,
+																SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
 {			
 
 	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
@@ -1192,8 +1503,27 @@
 	/* 1. Chip Select low */
 	_SPI_NAND_READ_CHIP_SELECT_LOW();
 	
-	/* 2. Send 03h opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_SINGLE );
+	/* 2. Send opcode */
+	switch (read_mode)
+	{
+		/* 03h */
+		case SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_SINGLE );
+			break;
+
+		/* 3Bh */
+		case SPI_NAND_FLASH_READ_SPEED_MODE_DUAL:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_DUAL );
+			break;
+
+		/* 6Bh */
+		case SPI_NAND_FLASH_READ_SPEED_MODE_QUAD:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_QUAD );
+			break;
+
+		default:
+			break;
+	}
 	
 	/* 3. Send data_offset addr */
 	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND )
@@ -1201,7 +1531,6 @@
 		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
 	}
 	
-	
 	if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
 	{
 		if( _plane_select_bit == 0)
@@ -1226,202 +1555,86 @@
 	}	
 	
 	/* 4. Read n byte (len) data */
-	_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_SINGLE);
+	switch (read_mode)
+	{
+		case SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE:
+			_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_SINGLE);
+			break;
+
+		case SPI_NAND_FLASH_READ_SPEED_MODE_DUAL:
+			_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_DUAL);
+			break;
+
+		case SPI_NAND_FLASH_READ_SPEED_MODE_QUAD:
+			_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_QUAD);
+			break;
+
+		default:
+			break;
+	}
 		
 	/* 5. Chip Select High */
 	_SPI_NAND_READ_CHIP_SELECT_HIGH();
-		
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache_single_speed : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);	
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);
 	
 	return (rtn_status);
 }
 
 /*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_dual_speed( u32   data_offset,
- *                                                                                     u32   len,
- *                                                                                     u8    *ptr_rtn_buf )
- * PURPOSE : To implement the SPI nand protocol for read from cache with dual speed.
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load( u32     addr,
+ *                                                                       u8      *ptr_data,
+ *                                                                       u32     len,
+ *																		 u32 write_mode)
+ * PURPOSE : To implement the SPI nand protocol for program load, with single speed.
  * AUTHOR  : Chuck Kuo
  * CALLED BY
  *   -
  * CALLS
  *   -
  * PARAMs  :
- *   INPUT : data_offset  - The data_offset variable of this function.
- *           len          - The len variable of this function.
- *   OUTPUT: ptr_rtn_buf  - A pointer to the ptr_rtn_buf variable.
+ *   INPUT : addr      - The addr variable of this function.
+ *           ptr_data  - A pointer to the ptr_data variable.
+ *           len       - The len variable of this function.
+ *   OUTPUT: None
  * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
  * NOTES   :
  * MODIFICTION HISTORY:
- * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
  *
  *------------------------------------------------------------------------------------
  */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_dual_speed( u32 data_offset, 
-																		  u32 len, 
-																		  u8 *ptr_rtn_buf,
-																		  SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
-{			
-	
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load ( u32 addr,
+																		  u8 *ptr_data,
+																		  u32 len,
+																		  u32 write_mode)
+{
+
 	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
 	
 	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
 	
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load: addr=0x%x, len=0x%x\n", addr, len );
+
 	/* 1. Chip Select low */
 	_SPI_NAND_READ_CHIP_SELECT_LOW();
 	
-	/* 2. Send 3Bh opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_DUAL );
-	
-	/* 3. Send data_offset addr */
-	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND )
+	/* 2. Send opcode */
+	switch (write_mode)
 	{
-		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
-	}	
-	
-	if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
-	{
-		if( _plane_select_bit == 0)
-		{
-			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xef)) );
-		}
-		if( _plane_select_bit == 1)
-		{
-			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) | (0x10)) );
-		}				
-	}	
-	else
-	{
-		_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xff)) );
-	}
-
-	_SPI_NAND_WRITE_ONE_BYTE( ((data_offset      ) &(0xff)) );
-		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
-	
-	/* 4. Read n byte (len) data */
-	_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_DUAL);
-		
-	/* 5. Chip Select High */
-	_SPI_NAND_READ_CHIP_SELECT_HIGH();
-	
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache_dual_speed : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);
-	
-	return (rtn_status);
-}
+		/* 02h */
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_SINGLE );
+			break;
 
-/*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_quad_speed( u32   data_offset,
- *                                                                                     u32   len,
- *                                                                                     u8    *ptr_rtn_buf )
- * PURPOSE : To implement the SPI nand protocol for read from cache with quad speed.
- * AUTHOR  : Chuck Kuo
- * CALLED BY
- *   -
- * CALLS
- *   -
- * PARAMs  :
- *   INPUT : data_offset  - The data_offset variable of this function.
- *           len          - The len variable of this function.
- *   OUTPUT: ptr_rtn_buf  - A pointer to the ptr_rtn_buf variable.
- * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
- * NOTES   :
- * MODIFICTION HISTORY:
- * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
- *
- *------------------------------------------------------------------------------------
- */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_quad_speed( u32 data_offset, 
-																		  u32 len, 
-																		  u8 *ptr_rtn_buf,
-																		  SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
-{			
-	
-	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
-	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-	
-	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
-	
-	/* 1. Chip Select low */
-	_SPI_NAND_READ_CHIP_SELECT_LOW();
-	
-	/* 2. Send 6Bh opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_QUAD );
-	
-	/* 3. Send data_offset addr */
-	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND )
-	{
-		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
-	}		
+		/* 32h */
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_QUAD );
+			break;
 
-	if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
-	{
-		if( _plane_select_bit == 0)
-		{
-			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xef)) );
-		}
-		if( _plane_select_bit == 1)
-		{
-			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) | (0x10)) );
-		}				
-	}	
-	else
-	{
-		_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xff)) );
+		default:
+			break;
 	}
-	_SPI_NAND_WRITE_ONE_BYTE( ((data_offset      ) &(0xff)) );
-		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
-	
-	/* 4. Read n byte (len) data */
-	_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_QUAD);
-		
-	/* 5. Chip Select High */
-	_SPI_NAND_READ_CHIP_SELECT_HIGH();
-	
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache_quad_speed : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);
-	
-	return (rtn_status);
-}
-
-/*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_single_speed( u32     addr,
- *                                                                       u8      *ptr_data,
- *                                                                       u32     len       )
- * PURPOSE : To implement the SPI nand protocol for program load, with single speed.
- * AUTHOR  : Chuck Kuo
- * CALLED BY
- *   -
- * CALLS
- *   -
- * PARAMs  :
- *   INPUT : addr      - The addr variable of this function.
- *           ptr_data  - A pointer to the ptr_data variable.
- *           len       - The len variable of this function.
- *   OUTPUT: None
- * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
- * NOTES   :
- * MODIFICTION HISTORY:
- * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
- *
- *------------------------------------------------------------------------------------
- */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_single_speed ( u32 addr, 
-																		  u8 *ptr_data, 
-																		  u32 len )
-{
-
-	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
-	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-	
-	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
-	
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_single_speed: addr=0x%x, len=0x%x\n", addr, len );
-	
-	/* 1. Chip Select low */
-	_SPI_NAND_READ_CHIP_SELECT_LOW();
-	
-	/* 2. Send 02h opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_SINGLE );
 	
 	/* 3. Send address offset */
 	if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
@@ -1443,74 +1656,19 @@
 	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & (0xff)) );
 	
 	/* 4. Send data */
-	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_SINGLE);
-	
-	/* 5. Chip Select High */
-	_SPI_NAND_READ_CHIP_SELECT_HIGH();	
-	
-	return (rtn_status);
-}
-
-/*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_quad_speed( u32  addr,
- *                                                                                  u8   *ptr_data,
- *                                                                                  u32  len       )
- * PURPOSE : To implement the SPI nand protocol for program load, with quad speed.
- * AUTHOR  : Chuck Kuo
- * CALLED BY
- *   -
- * CALLS
- *   -
- * PARAMs  :
- *   INPUT : addr      - The addr variable of this function.
- *           ptr_data  - A pointer to the ptr_data variable.
- *           len       - The len variable of this function.
- *   OUTPUT: None
- * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
- * NOTES   :
- * MODIFICTION HISTORY:
- * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
- *
- *------------------------------------------------------------------------------------
- */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_quad_speed ( u32 addr, 
-																		u8 *ptr_data, 
-																		u32 len )
-{
-	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
-	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-	
-	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
-	
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_quad_speed: addr=0x%x, len=0x%x\n", addr, len );
-	
-	/* 1. Chip Select low */
-	_SPI_NAND_READ_CHIP_SELECT_LOW();
-	
-	/* 2. Send 32h opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_QUAD );
-	
-	/* 3. Send address offset */
-	if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE)  )
-	{
-		if( _plane_select_bit == 0)
-		{
-			_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) & (0xef)) );
-		}
-		if( _plane_select_bit == 1)
-		{
-			_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) | (0x10)) );
-		}				
-	}	
-	else
+	switch (write_mode)
 	{
-		_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) & (0xff)) );
-	}
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+			_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_SINGLE);
+			break;
 
-	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & (0xff)) );
-	
-	/* 4. Send data */
-	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_QUAD);
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+			_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_QUAD);
+			break;
+
+		default:
+			break;
+	}
 	
 	/* 5. Chip Select High */
 	_SPI_NAND_READ_CHIP_SELECT_HIGH();	
@@ -1518,11 +1676,11 @@
 	return (rtn_status);
 }
 
-
 /*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_single_speed( u32     addr,
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random( u32     addr,
  *                                                                       u8      *ptr_data,
- *                                                                       u32     len       )
+ *                                                                       u32     len,
+ *																		 u32 write_mode)
  * PURPOSE : To implement the SPI nand protocol for program load, with single speed.
  * AUTHOR  : Chuck Kuo
  * CALLED BY
@@ -1541,75 +1699,53 @@
  *
  *------------------------------------------------------------------------------------
  */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_single_speed ( u32 addr, 
-																		  u8 *ptr_data, 
-																		  u32 len )
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random ( u32 addr,
+																  u8 *ptr_data,
+																  u32 len,
+																  u32 write_mode)
 {
 	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
 	
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_single_speed: addr=0x%x, len=0x%x\n", addr, len );
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_random: addr=0x%x, len=0x%x\n", addr, len );
 	
 	/* 1. Chip Select low */
 	_SPI_NAND_READ_CHIP_SELECT_LOW();
 	
-	/* 2. Send 84h opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_RAMDOM_SINGLE );
-	
-	/* 3. Send address offset */
-	_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8  ) & 0xff) );
-	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & 0xff) );
-	
-	/* 4. Send data */
-	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_SINGLE);
-	
-	/* 5. Chip Select High */
-	_SPI_NAND_READ_CHIP_SELECT_HIGH();	
-	
-	return (rtn_status);
-}
+	/* 2. Send opcode */
+	switch (write_mode)
+	{
+		/* 84 */
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_RAMDOM_SINGLE );
+			break;
 
-/*------------------------------------------------------------------------------------
- * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_quad_speed( u32  addr,
- *                                                                                  u8   *ptr_data,
- *                                                                                  u32  len       )
- * PURPOSE : To implement the SPI nand protocol for program load, with quad speed.
- * AUTHOR  : Chuck Kuo
- * CALLED BY
- *   -
- * CALLS
- *   -
- * PARAMs  :
- *   INPUT : addr      - The addr variable of this function.
- *           ptr_data  - A pointer to the ptr_data variable.
- *           len       - The len variable of this function.
- *   OUTPUT: None
- * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
- * NOTES   :
- * MODIFICTION HISTORY:
- * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
- *
- *------------------------------------------------------------------------------------
- */
-static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_quad_speed ( u32 addr, 
-																		u8 *ptr_data, 
-																		u32 len )
-{
-	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-	
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_quad_speed: addr=0x%x, len=0x%x\n", addr, len );
-	
-	/* 1. Chip Select low */
-	_SPI_NAND_READ_CHIP_SELECT_LOW();
-	
-	/* 2. Send 34h opcode */
-	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_RAMDON_QUAD );
+		/* 34h */
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+			_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_RAMDON_QUAD );
+			break;
+
+		default:
+			break;
+	}
 	
 	/* 3. Send address offset */
 	_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8  ) & 0xff) );
 	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & 0xff) );
 	
 	/* 4. Send data */
-	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_QUAD);
+	switch (write_mode)
+	{
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+			_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_SINGLE);
+			break;
+
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+			_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_QUAD);
+			break;
+
+		default:
+			break;
+	}
 	
 	/* 5. Chip Select High */
 	_SPI_NAND_READ_CHIP_SELECT_HIGH();	
@@ -1617,7 +1753,6 @@
 	return (rtn_status);
 }
 
-
 /*------------------------------------------------------------------------------------
  * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_execute( u32  addr )
  * PURPOSE : To implement the SPI nand protocol for program execute.
@@ -1659,6 +1794,50 @@
 	return (rtn_status);
 }
 
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_die_select_1( u8 die_id)
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send C2h opcode (Die Select) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_DIE_SELECT );
+
+	/* 3. Send Die ID */
+	_SPI_NAND_WRITE_ONE_BYTE( die_id );
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_die_select_1\n");
+
+	return (rtn_status);
+}
+
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_die_select_2( u8 die_id)
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	unsigned char feature;
+
+	rtn_status = spi_nand_protocol_get_status_reg_4(&feature);
+	if(rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR) {
+		_SPI_NAND_PRINTF("spi_nand_protocol_die_select_2 get die select fail.\n");
+		return (rtn_status);
+	}
+
+	if(die_id == 0) {
+		feature &= ~(0x40);
+	} else {
+		feature |= 0x40;
+	}
+	rtn_status = spi_nand_protocol_set_status_reg_4(feature);
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_die_select_2\n");
+
+	return (rtn_status);
+}
+
 static void spi_nand_select_die ( u32 page_number )
 {
 	struct SPI_NAND_FLASH_INFO_T *ptr_dev_info_t;
@@ -1666,16 +1845,27 @@
 
 	ptr_dev_info_t = _SPI_NAND_GET_DEVICE_INFO_PTR;
 
-	if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_HAVE))
-	{
+	if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_1_HAVE)) {
+		/* single die = 1024blocks * 64pages */
 		die_id = ((page_number >> 16) & 0xff);
 
 		if (_die_id != die_id)
 		{
 			_die_id = die_id;
-			spi_nand_protocol_die_select(die_id);
+			spi_nand_protocol_die_select_1(die_id);
 
-			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_protocol_die_select: die_id=0x%x\n", die_id);
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_protocol_die_select_1: die_id=0x%x\n", die_id);
+		}
+	} else if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_2_HAVE) ) {
+		/* single die = 2plans * 1024blocks * 64pages */
+		die_id = ((page_number >> 17) & 0xff);
+
+		if (_die_id != die_id)
+		{
+			_die_id = die_id;
+			spi_nand_protocol_die_select_2(die_id);
+
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_protocol_die_select_2: die_id=0x%x\n", die_id);
 		}
 	}
 }
@@ -1685,131 +1875,97 @@
 	u8								status;
 	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-	
-	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
 
-	spi_nand_protocol_get_status_reg_3( &status); 	
-
-
-	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "ecc_fail_check: status=0x%x\n", status);
-
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE )
-	{
-
-
-		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UAYIG)
-		{
-			if( ((status & 0x30) >> 4) == 0x2 )
-			{
-				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
-			}
-		}
-
-		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UBYIG)
-		{
-			if( ((status & 0x30) >> 4) == 0x2 )
-			{
-				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
-			}
-		}
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
 
-		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG)
-		{
-			if( ((status & 0x30) >> 4) == 0x2 )
-			{
-				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
-			}
-		}
+	spi_nand_protocol_get_status_reg_3( &status);
 
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "ecc_fail_check: status=0x%x\n", status);
 
-		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG)
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE)
+	{
+		if((ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UAYIG) ||
+		   (ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UBYIG) ||
+		   (ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG) ||
+		   (ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F4GQ4UBYIG))
 		{
-			if( ((status & 0x70) >> 4) == 0x7 )
+			if(((status & 0x30) >> 4) == 0x2)
 			{
 				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 			}
 		}
 
-		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG)
+		if((ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG) ||
+			(ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG) ||
+			(ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F4GQ4UCYIG))
 		{
-			if( ((status & 0x70) >> 4) == 0x7 )
+			if(((status & 0x70) >> 4) == 0x7)
 			{
 				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 			}
-		}		
-	
+		}
 	}
 
-
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_MXIC )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_MXIC)
 	{
-
-		if( ((status & 0x30) >> 4) == 0x2 )
+		if(((status & 0x30) >> 4) == 0x2)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}
 	
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_WINBOND )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_WINBOND)
 	{
-
-		if( ((status & 0x30) >> 4) == 0x2 )
+		if(((status & 0x30) >> 4) == 0x2)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}	
 
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ESMT )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ESMT)
 	{
-
-		if( ((status & 0x30) >> 4) == 0x2 )
+		if(((status & 0x30) >> 4) == 0x2)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}		
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ZENTEL )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ZENTEL)
 	{
-
-		if( ((status & 0x30) >> 4) == 0x2 )
+		if(((status & 0x30) >> 4) == 0x2)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ETRON )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ETRON)
 	{
-
-		if( ((status & 0x30) >> 4) == 0x2 )
+		if(((status & 0x30) >> 4) == 0x2)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_TOSHIBA )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_TOSHIBA)
 	{
-
-		if( ((status & 0x30) >> 4) == 0x2 )
+		if(((status & 0x30) >> 4) == 0x2)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}	
-	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_MICRON )
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_MICRON)
 	{
-
-		if( ((status & 0x70) >> 4) == 0x2 )
+		if(((status & 0x70) >> 4) == 0x2)
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+	}
+	if(ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_HEYANG)
+	{
+		if(((status & 0x70) >> 4) == 0x7)
 		{
 			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
 		}
-
 	}
-
 	
-
-	if( rtn_status == SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK)
+	if(rtn_status == SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK)
 	{
 		_SPI_NAND_PRINTF("[spinand_ecc_fail_check] : ECC cannot recover detected !, page=0x%x\n", page_number);
 	}
@@ -1860,7 +2016,9 @@
 		
 		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_load_page_into_cache : status =0x%x\n", status);
 
-		rtn_status = ecc_fail_check(page_number);
+		if(_spi_dma_mode == 0) {
+			rtn_status = ecc_fail_check(page_number);
+		}
 	}
 	
 	return (rtn_status);
@@ -1868,6 +2026,52 @@
 }
 
 /*------------------------------------------------------------------------------------
+ * FUNCTION: spi_nand_set_clock_speed( u32 clock_factor)
+ * PURPOSE : To set SPI clock.
+ *                 clock_factor = 0
+ *                   EN7512: SPI clock = 500MHz / 40 = 12.5MHz
+ *                   EN7522: SPI clock = 400MHz / 40 = 10MHz
+ *                 clock_factor > 0
+ *                   EN7512: SPI clock = 500MHz / (clock_factor * 2)
+ *                   EN7522: SPI clock = 400MHz / (clock_factor * 2)
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : clock_factor - The SPI clock divider.
+ * RETURN  : NONE.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_set_clock_speed( u32 clock_factor)
+{
+	unsigned long val;
+	unsigned long dividend;
+
+	if(!isFPGA) {
+		val  = VPint(_SPI_FREQUENCY_ADJUST_REG);
+		val &= 0xffff0000;
+		VPint(_SPI_FREQUENCY_ADJUST_REG) = val;
+
+		val |= (((clock_factor) << 8)|1);
+		VPint(_SPI_FREQUENCY_ADJUST_REG) = val;
+
+		if(isEN7526c) {
+			dividend = 400;
+		} else {
+			dividend = 500;
+		}
+
+		_SPI_NAND_PRINTF("Set SPI Clock to %d Mhz\n", (dividend/(clock_factor * 2)));
+	} else {
+		_SPI_NAND_PRINTF("FPGA can not Set SPI Clock, FPGA SPI Clock is 10 Mhz\n");
+	}
+}
+
+/*------------------------------------------------------------------------------------
  * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_block_aligned_check( u32   addr,
  *                                                                     u32   len  )
  * PURPOSE : To check block align.
@@ -1913,7 +2117,6 @@
 	return (rtn_status);
 }
 
-
 static SPI_NAND_FLASH_RTN_T spi_nand_erase_block ( u32 block_index)
 {
 
@@ -1987,6 +2190,11 @@
 		
 	_SPI_NAND_SEMAPHORE_LOCK();	
 	
+	SPI_CONTROLLER_CONF_T	spi_conf_t;
+
+	/* Switch to manual mode*/
+	_SPI_NAND_ENABLE_MANUAL_MODE();
+
 	SPI_NAND_Flash_Clear_Read_Cache_Data();
 	
 	/* 1. Check the address and len must aligned to NAND Flash block size */
@@ -2012,7 +2220,7 @@
 			rtn_status = spi_nand_erase_block(block_index);
 						
 			/* 2.6 Check Erase Fail Bit */
-			if( rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR )
+			if(rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR)
 			{
 #if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
 					if (update_bmt(addr,UPDATE_ERASE_FAIL, NULL, NULL))
@@ -2032,7 +2240,7 @@
 				break;
 
 #endif
-			}			
+			}
 			
 			/* 2.7 Erase next block if needed */
 			addr		+= _current_flash_info_t.erase_size;
@@ -2053,9 +2261,7 @@
 
 
 
-static SPI_NAND_FLASH_RTN_T spi_nand_read_page ( u32 page_number, 
-  													   SPI_NAND_FLASH_READ_SPEED_MODE_T speed_mode
-  													 )
+static SPI_NAND_FLASH_RTN_T spi_nand_read_page (u32 page_number, SPI_NAND_FLASH_READ_SPEED_MODE_T speed_mode)
 {
 
 	u32			 					idx=0;
@@ -2063,9 +2269,26 @@
 	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
 	struct spi_nand_flash_oobfree 	*ptr_oob_entry_idx;	
+	u16 							read_addr;
+	SPI_NFI_MISC_SPEDD_CONTROL_T	dma_speed_mode;
+	u32								read_cmd;
 
 	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;			
 
+	SPI_NFI_CONF_T			spi_nfi_conf_t;
+	SPI_ECC_DECODE_CONF_T	spi_ecc_decode_conf_t;
+	u32 					check_cnt;
+
+	SPI_ECC_DECODE_STATUS_T decode_status_t;
+	SPI_CONTROLLER_CONF_T	spi_conf_t;
+	u32 					offset1, offset2, offset3, dma_sec_size;
+
+	/* read from read_addr index in the page */
+	read_addr = 0;
+
+	/* Switch to manual mode*/
+	_SPI_NAND_ENABLE_MANUAL_MODE();
+
 	/* 1. Load Page into cache of NAND Flash Chip */
 	if( spi_nand_load_page_into_cache(page_number) == SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK )
 	{
@@ -2091,61 +2314,312 @@
 			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"spi_nand_read_page: plane select = 0x%x\n",  _plane_select_bit);			
 		}
 		
-		switch (speed_mode)
+		if( _spi_dma_mode ==1  )
 		{
-			case SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE:
-				spi_nand_protocol_read_from_cache_single_speed( 0, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], ptr_dev_info_t->dummy_mode );
-				break;
-				
-			case SPI_NAND_FLASH_READ_SPEED_MODE_DUAL:
-				spi_nand_protocol_read_from_cache_dual_speed( 0, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], ptr_dev_info_t->dummy_mode );
-				break;										
+			SPI_CONTROLLER_Get_Configure(&spi_conf_t);
+			spi_conf_t.dummy_byte_num = 0 ;
+			spi_conf_t.mode = SPI_CONTROLLER_MODE_DMA;
+			SPI_CONTROLLER_Set_Configure(&spi_conf_t);
+
+			/* Reset NFI statemachie is neccessary */
+			SPI_NFI_Reset();
+
+			SPI_NFI_Get_Configure(&spi_nfi_conf_t);
+			SPI_NFI_Set_Configure(&spi_nfi_conf_t);
+
+			SPI_ECC_Decode_Get_Configure(&spi_ecc_decode_conf_t);
+			SPI_ECC_Decode_Set_Configure(&spi_ecc_decode_conf_t);
+
+			if( spi_nfi_conf_t.hw_ecc_t == SPI_NFI_CON_HW_ECC_Enable )
+			{
+				SPI_ECC_Decode_Get_Configure(&spi_ecc_decode_conf_t);
 				
-			case SPI_NAND_FLASH_READ_SPEED_MODE_QUAD:
-				spi_nand_protocol_read_from_cache_quad_speed( 0, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], ptr_dev_info_t->dummy_mode );
-				break;
+				if( spi_ecc_decode_conf_t.decode_en == SPI_ECC_DECODE_ENABLE )
+				{
+					(spi_ecc_decode_conf_t.decode_block_size)  = (((spi_nfi_conf_t.fdm_ecc_num) + 512)*8) + ((spi_ecc_decode_conf_t.decode_ecc_abiliry) *13);
 
-			default:
-				break;
+					SPI_ECC_Decode_Set_Configure(&spi_ecc_decode_conf_t);
+
+					_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_read_page: decode block size=0x%x, ecc_num=0x%x, ecc_ab=0x%x\n", VPint(0xBFA12104), (spi_nfi_conf_t.fdm_ecc_num), (spi_ecc_decode_conf_t.decode_ecc_abiliry));
+
+					_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_read_page : SPI_ECC_Decode_Enable \n");
+
+					SPI_ECC_Decode_Disable();
+					SPI_ECC_Encode_Disable();
+					SPI_ECC_Decode_Enable();
+				}
+			}
+
+			/* Set plane select */
+			if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE)) {
+				if( _plane_select_bit == 0) {
+					read_addr &= ~(0x1000);
+				} else if( _plane_select_bit == 1) {
+					read_addr |= (0x1000);
+				}
+			}
+
+			switch (speed_mode)
+			{
+				case SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE:
+					dma_speed_mode = SPI_NFI_MISC_CONTROL_X1;
+					read_cmd = _SPI_NAND_OP_READ_FROM_CACHE_SINGLE;
+					break;
+
+				case SPI_NAND_FLASH_READ_SPEED_MODE_DUAL:
+					dma_speed_mode = SPI_NFI_MISC_CONTROL_X2;
+					read_cmd = _SPI_NAND_OP_READ_FROM_CACHE_DUAL;
+					break;
+
+				case SPI_NAND_FLASH_READ_SPEED_MODE_QUAD:
+					dma_speed_mode = SPI_NFI_MISC_CONTROL_X4;
+					read_cmd = _SPI_NAND_OP_READ_FROM_CACHE_QUAD;
+					break;
+
+				default:
+					_SPI_NAND_PRINTF("[Error] Read DMA : read speed setting error:%d!\n", speed_mode);
+					dma_speed_mode = SPI_NFI_MISC_CONTROL_X1;
+					read_cmd = _SPI_NAND_OP_READ_FROM_CACHE_SINGLE;
+					break;
+			}
+
+			rtn_status = SPI_NFI_Read_SPI_NAND_Page(dma_speed_mode, read_cmd, read_addr, K1_TO_PHY(&dma_read_page[0]));
+
+			if( spi_nfi_conf_t.hw_ecc_t == SPI_NFI_CON_HW_ECC_Enable )
+			{
+				if( spi_ecc_decode_conf_t.decode_en == SPI_ECC_DECODE_ENABLE )
+				{
+					/* Check Decode done or not */
+					for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_ECC_DONE_MAX_TIMES ; check_cnt ++)
+					{
+						SPI_ECC_Decode_Check_Done (&decode_status_t);
+
+						if( decode_status_t == SPI_ECC_DECODE_STATUS_DONE  )
+						{
+							break;
+						}
+					}
+					if(check_cnt == _SPI_NFI_CHECK_ECC_DONE_MAX_TIMES)
+					{
+						_SPI_NAND_PRINTF("[Error] Read ECC : Check Decode Done Timeout ! \n");
+
+						SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+						/*  return  somthing ? */
+						rtn_status = SPI_ECC_DECODE_STATUS_TIMEOUT;
+					}
+
+					if( SPI_ECC_DECODE_Check_Correction_Status() == SPI_ECC_RTN_CORRECTION_ERROR )
+					{
+						_SPI_NAND_PRINTF("[Error] Read ECC : ECC Fail! page:0x%x\n", page_number);
+						SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+						/* Switch to manual mode*/
+						_SPI_NAND_ENABLE_MANUAL_MODE();
+
+						/*  return somthing ?*/
+						rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+					}
+				}
+			}
+
+			if( ( spi_nfi_conf_t.auto_fdm_t) == SPI_NFI_CON_AUTO_FDM_Disable ) {
+				memcpy(&_current_cache_page[0], K0_TO_K1(&dma_read_page[0]), ptr_dev_info_t->page_size + ptr_dev_info_t->oob_size);
+			} else {
+				memcpy(&_current_cache_page[0], K0_TO_K1(&dma_read_page[0]), ptr_dev_info_t->page_size);
+			}
+
+			/* Switch to manual mode*/
+			_SPI_NAND_ENABLE_MANUAL_MODE();
+		}
+		else
+		{
+			spi_nand_protocol_read_from_cache(read_addr, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], speed_mode, ptr_dev_info_t->dummy_mode );
 		}
 		
 		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: after read, _current_cache_page:\n");
 		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], _SPI_NAND_CACHE_SIZE);
 
 		/* Divide read page into data segment and oob segment  */
-		memcpy( &_current_cache_page_data[0], &_current_cache_page[0], (ptr_dev_info_t->page_size) );
-		memcpy( &_current_cache_page_oob[0],  &_current_cache_page[(ptr_dev_info_t->page_size)], (ptr_dev_info_t->oob_size) );
-
-		idx = 0;
-		ptr_oob_entry_idx = (struct spi_nand_flash_oobfree*) &( (ptr_dev_info_t->oob_free_layout)->oobfree );
-
-		/* Transter oob area from physical offset into logical offset */
-		for( i=0; (i<SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX) && (ptr_oob_entry_idx[i].len) && (idx< ((ptr_dev_info_t->oob_free_layout)->oobsize)) ; i++)
+		if( _spi_dma_mode ==1  )
 		{
-			for(j=0; (j< (ptr_oob_entry_idx[i].len)) && (idx<(ptr_dev_info_t->oob_free_layout->oobsize)) ; j++)
+			if( ( spi_nfi_conf_t.auto_fdm_t) == SPI_NFI_CON_AUTO_FDM_Disable )
+			{
+				offset1 = 0;
+				offset2 = 0;
+				offset3 = 0;
+				dma_sec_size = ((spi_nfi_conf_t.page_size_t)/ (spi_nfi_conf_t.sec_num));
+				for(i =0 ; i< (spi_nfi_conf_t.sec_num) ; i++ )
+				{
+					memcpy( &_current_cache_page_data[offset1], &_current_cache_page[offset2], dma_sec_size );
+					memcpy( &_current_cache_page_oob[offset3], &_current_cache_page[offset2+dma_sec_size], (spi_nfi_conf_t.spare_size_t) );
+					offset1 += dma_sec_size;
+					offset2 += (dma_sec_size+ (spi_nfi_conf_t.spare_size_t));
+					offset3 += (spi_nfi_conf_t.spare_size_t);
+				}
+			}
+			else /* Auto FDM enable : Data and oob alternate ,  Data inside DRAM , oob inside NFI register */
 			{
-				/* _SPI_NAND_PRINTF("i=%d , j=%d, len=%d, idx=%d, size=%d\n", i, j,(ptr_oob_entry_idx[i].len), idx, (ptr_dev_info_t->oob_free_layout->oobsize) ); */
-				_current_cache_page_oob_mapping[idx] = _current_cache_page_oob[(ptr_oob_entry_idx[i].offset)+j];
-				idx++;
+				memcpy( &_current_cache_page_data[0], &_current_cache_page[0], (ptr_dev_info_t->page_size) );
+				SPI_NFI_Read_SPI_NAND_FDM( &_current_cache_page_oob[0], (ptr_dev_info_t->oob_size));
 			}
-		}	
 
-		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page:\n");
-		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)));
-		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page_oob:\n");
-		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob[0], (ptr_dev_info_t->oob_size));		
-		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page_oob_mapping:\n");
-		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob_mapping[0], (ptr_dev_info_t->oob_size));
+			memcpy( &_current_cache_page_oob_mapping[0], &_current_cache_page_oob[0], ptr_dev_info_t->oob_size);
+		}
+		else
+		{
+			memcpy( &_current_cache_page_data[0], &_current_cache_page[0], (ptr_dev_info_t->page_size) );
+			memcpy( &_current_cache_page_oob[0],  &_current_cache_page[(ptr_dev_info_t->page_size)], (ptr_dev_info_t->oob_size) );
+
+			idx = 0;
+			ptr_oob_entry_idx = (struct spi_nand_flash_oobfree*) &( (ptr_dev_info_t->oob_free_layout)->oobfree );
 
+			if( _ondie_ecc_flag == 1)   /*  When OnDie ecc is enable,  mapping oob area is neccessary */
+			{
+				/* Transter oob area from physical offset into logical offset */
+				for( i=0; (i<SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX) && (ptr_oob_entry_idx[i].len) && (idx< ((ptr_dev_info_t->oob_free_layout)->oobsize)) ; i++)
+				{
+					for(j=0; (j< (ptr_oob_entry_idx[i].len)) && (idx<(ptr_dev_info_t->oob_free_layout->oobsize)) ; j++)
+					{
+						/* _SPI_NAND_PRINTF("i=%d , j=%d, len=%d, idx=%d, size=%d\n", i, j,(ptr_oob_entry_idx[i].len), idx, (ptr_dev_info_t->oob_free_layout->oobsize) ); */
+						_current_cache_page_oob_mapping[idx] = _current_cache_page_oob[(ptr_oob_entry_idx[i].offset)+j];
+						idx++;
+					}
+				}
+			}
+			else
+			{
+				memcpy( &_current_cache_page_oob_mapping[0],  &_current_cache_page_oob[0], (ptr_dev_info_t->oob_size) );
+			}
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page:\n");
+			_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)));
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page_oob:\n");
+			_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob[0], (ptr_dev_info_t->oob_size));
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page_oob_mapping:\n");
+			_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob_mapping[0], (ptr_dev_info_t->oob_size));
+		}
 		_current_page_num = page_number; 
 	}	
 
-
 	return rtn_status;
+}
+
+static SPI_NAND_FLASH_RTN_T spi_nand_dma_program_load(u32 addr, u32 oob_len, SPI_NAND_FLASH_WRITE_SPEED_MODE_T speed_mode)
+{
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 
+	SPI_CONTROLLER_CONF_T	spi_conf_t;
+	SPI_NFI_CONF_T			spi_nfi_conf_t;
+	SPI_ECC_ENCODE_CONF_T	spi_ecc_encode_conf_t;
+	SPI_ECC_DECODE_CONF_T	spi_ecc_decode_conf_t;
+	u32 					offset1, offset2, offset3, dma_sec_size;
+	u32 					i=0;
+	SPI_NAND_FLASH_RTN_T	rtn_status;
+	u16 					write_addr;
+	u32						write_cmd;
+	SPI_NFI_MISC_SPEDD_CONTROL_T	dma_speed_mode;
 
-}
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	/* Set plane select */
+	if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE)) {
+		if( _plane_select_bit == 0) {
+			write_addr &= ~(0x1000);
+		} else if( _plane_select_bit == 1) {
+			write_addr |= (0x1000);
+		}
+	} else {
+		write_addr = addr;
+	}
+
+	switch (speed_mode)
+	{
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+			dma_speed_mode = SPI_NFI_MISC_CONTROL_X1;
+			write_cmd = _SPI_NAND_OP_PROGRAM_LOAD_SINGLE;
+			break;
 						
+		case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+			dma_speed_mode = SPI_NFI_MISC_CONTROL_X4;
+			write_cmd = _SPI_NAND_OP_PROGRAM_LOAD_QUAD;
+			break;
+
+		default:
+			_SPI_NAND_PRINTF("[Error] Write DMA : write speed setting error:%d!\n", speed_mode);
+			dma_speed_mode = SPI_NFI_MISC_CONTROL_X1;
+			write_cmd = _SPI_NAND_OP_PROGRAM_LOAD_SINGLE;
+			break;
+	}
+
+	SPI_CONTROLLER_Get_Configure(&spi_conf_t);
+	spi_conf_t.dummy_byte_num = 0 ;
+	spi_conf_t.mode = SPI_CONTROLLER_MODE_DMA;
+	SPI_CONTROLLER_Set_Configure(&spi_conf_t);
+
+	/* Reset NFI statemachie is neccessary */
+	SPI_NFI_Reset();
+
+	SPI_NFI_Get_Configure(&spi_nfi_conf_t);
+	SPI_NFI_Set_Configure(&spi_nfi_conf_t);
+
+	SPI_ECC_Encode_Get_Configure(&spi_ecc_encode_conf_t);
+	SPI_ECC_Encode_Set_Configure(&spi_ecc_encode_conf_t);
+
+	if( spi_nfi_conf_t.hw_ecc_t == SPI_NFI_CON_HW_ECC_Enable )
+	{
+		SPI_ECC_Encode_Get_Configure(&spi_ecc_encode_conf_t);
+
+		if( spi_ecc_encode_conf_t.encode_en == SPI_ECC_ENCODE_ENABLE )
+		{
+			(spi_ecc_encode_conf_t.encode_block_size)  = ((spi_nfi_conf_t.fdm_ecc_num) + 512) ;
+
+			SPI_ECC_Encode_Set_Configure(&spi_ecc_encode_conf_t);
+
+			SPI_ECC_Encode_Disable();
+			SPI_ECC_Decode_Disable();
+			SPI_ECC_Encode_Enable();
+		}
+	}
+
+	/*Set oob */
+	if( oob_len > 0 )	/* Write OOB */
+	{
+		if( ( spi_nfi_conf_t.auto_fdm_t) == SPI_NFI_CON_AUTO_FDM_Disable )	/* Data and oob alternate */
+		{
+			offset1 = 0;
+			offset2 = 0;
+			offset3 = 0;
+			dma_sec_size = ((spi_nfi_conf_t.page_size_t)/ (spi_nfi_conf_t.sec_num));
+
+			for(i =0 ; i< (spi_nfi_conf_t.sec_num) ; i++ )
+			{
+				memcpy( &_current_cache_page[offset2], &_current_cache_page_data[offset1],	dma_sec_size );
+				memcpy( &_current_cache_page[offset2+dma_sec_size], &_current_cache_page_oob[offset3] , (spi_nfi_conf_t.spare_size_t) );
+				offset1 += dma_sec_size;
+				offset2 += (dma_sec_size+ (spi_nfi_conf_t.spare_size_t));
+				offset3 += (spi_nfi_conf_t.fdm_num);
+			}
+
+			/* Set data */
+			memcpy(K0_TO_K1(&dma_write_page[0]), &_current_cache_page[0], ptr_dev_info_t->page_size + ptr_dev_info_t->oob_size);
+		}
+		else   /* Data inside DRAM , oob inside NFI register */
+		{
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_dma_program_load: set fdm\n");
+			SPI_NFI_Write_SPI_NAND_FDM(&_current_cache_page_oob[0], oob_len);
+
+			/* Set data */
+			memcpy(K0_TO_K1(&dma_write_page[0]), &_current_cache_page[0], ptr_dev_info_t->page_size);
+		}
+	}
+
+	rtn_status = SPI_NFI_Write_SPI_NAND_page(dma_speed_mode, write_cmd, write_addr, K1_TO_PHY(&dma_write_page[0]));
+
+	/* Switch to manual mode*/
+	_SPI_NAND_ENABLE_MANUAL_MODE();
+
+	return rtn_status;
+}
 
 
 static SPI_NAND_FLASH_RTN_T spi_nand_write_page(	u32 page_number, 
@@ -2163,11 +2637,47 @@
 		struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 		struct spi_nand_flash_oobfree 	*ptr_oob_entry_idx;	
 		SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+		u16 							write_addr;
+		int								data_content, oob_content;
+
+		/* write to write_addr index in the page */
+		write_addr = 0;
+
+		/* Switch to manual mode*/
+		_SPI_NAND_ENABLE_MANUAL_MODE();
 
 		ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;	
 
+		/* Skip write bland page for winbond flash */
+		if (ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_WINBOND) {
+			if((ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_W25N01GV) ||
+			   (ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_W25M02GV)) {
+				data_content = EMPTY_DATA;
+				for(idx = 0; idx < data_len; idx++) {
+					if(ptr_data[idx] != 0xFF) {
+						data_content = NONE_EMPTY_DATA;
+						break;
+					}
+				}
+
+				if(data_content == 0) {
+					oob_content = EMPTY_OOB;
+					for(idx = 0; idx < oob_len; idx++) {
+						if(ptr_oob[idx] != 0xFF) {
+							oob_content = NONE_EMPTY_OOB;
+							break;
+						}
+					}
+				}
+
+				if((data_content == EMPTY_DATA) && (oob_content == EMPTY_OOB)) {
+					return SPI_NAND_FLASH_RTN_NO_ERROR;
+				}
+			}
+		}
+
 		/* Read Current page data to software cache buffer */
-		spi_nand_read_page(page_number, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+		spi_nand_read_page(page_number, speed_mode);
 
 		/* Rewirte the software cahe buffer */
 		if(data_len > 0)
@@ -2177,24 +2687,38 @@
 
 		if( oob_len > 0 )	/* Write OOB */
 		{
-			ptr_oob_entry_idx = (struct spi_nand_flash_oobfree*) &( ptr_dev_info_t->oob_free_layout->oobfree );
-			
-			for( i=0; (i<SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX) && (ptr_oob_entry_idx[i].len) && ((idx< (ptr_dev_info_t->oob_free_layout->oobsize)) && (idx < oob_len))  ; i++)
+			if( _spi_dma_mode ==1  )
+			{
+				memcpy( &_current_cache_page_oob[0], &ptr_oob[0], oob_len );
+			}
+			else
 			{
-				for(j=0; (j< (ptr_oob_entry_idx[i].len)) && (idx<(ptr_dev_info_t->oob_free_layout->oobsize)) && ((idx< (ptr_dev_info_t->oob_free_layout->oobsize)) && (idx < oob_len)) ; j++)
+				if(_ondie_ecc_flag == 1)		/*  When OnDie ecc is enable,  mapping oob area is neccessary */
 				{
+					ptr_oob_entry_idx = (struct spi_nand_flash_oobfree*) &( ptr_dev_info_t->oob_free_layout->oobfree );
+
+					for( i=0; (i<SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX) && (ptr_oob_entry_idx[i].len) && ((idx< (ptr_dev_info_t->oob_free_layout->oobsize)) && (idx < oob_len))  ; i++)
+					{
+						for(j=0; (j< (ptr_oob_entry_idx[i].len)) && (idx<(ptr_dev_info_t->oob_free_layout->oobsize)) && ((idx< (ptr_dev_info_t->oob_free_layout->oobsize)) && (idx < oob_len)) ; j++)
+						{
 
-					_current_cache_page_oob[(ptr_oob_entry_idx[i].offset)+j] &= ptr_oob[idx];
-					idx++;
+							_current_cache_page_oob[(ptr_oob_entry_idx[i].offset)+j] &= ptr_oob[idx];
+							idx++;
+						}
+					}
+				}
+				else
+				{
+					memcpy( &_current_cache_page_oob[0], &ptr_oob[0], oob_len);
 				}
 			}			
 		}
 
-		memcpy( &_current_cache_page[0], &_current_cache_page_data[0], _SPI_NAND_PAGE_SIZE );
-		memcpy( &_current_cache_page[_SPI_NAND_PAGE_SIZE],  &_current_cache_page_oob[0], _SPI_NAND_OOB_SIZE );
+		memcpy( &_current_cache_page[0], &_current_cache_page_data[0], ptr_dev_info_t->page_size );
+		memcpy( &_current_cache_page[ptr_dev_info_t->page_size],  &_current_cache_page_oob[0], ptr_dev_info_t->oob_size );
 
 
-		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_write_page: data_offset=0x%x, date_len=0x%x, oob_offset=0x%x, oob_len=0x%x\n", data_offset, data_len, oob_offset, oob_len);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_write_page: page=0x%x, data_offset=0x%x, date_len=0x%x, oob_offset=0x%x, oob_len=0x%x\n", page_number, data_offset, data_len, oob_offset, oob_len);
 		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)));		
 	
 		if( ((ptr_dev_info_t->feature) & SPI_NAND_FLASH_PLANE_SELECT_HAVE)  )
@@ -2208,45 +2732,21 @@
 		spi_nand_select_die ( page_number );
 
 		/* Different Manafacture have different prgoram flow and setting */
-
-		if( ((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MXIC ) || \
-			((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_WINBOND ) || \
-			((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ESMT)  || \
-			((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ETRON) )
-		{							
-			/*	Enable write_to flash */
-			spi_nand_protocol_write_enable();		
-			
-			/* Proram data into buffer of SPI NAND chip */
-			switch( speed_mode )
-			{						
-				case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
-					spi_nand_protocol_program_load_single_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
-					break;
-					
-				case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
-					spi_nand_protocol_program_load_quad_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)));
-					break;
-
-				default:
-					break;
-			}				
-		}	
-		else if( ((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) )
+		if( ((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) )
 		{			
-
-			switch( speed_mode )
-			{						
-				case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
-					spi_nand_protocol_program_load_single_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
-					break;
-					
-				case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
-					spi_nand_protocol_program_load_quad_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
-					break;
-					
-				default:
-					break;
+			if( _spi_dma_mode ==1  )
+			{
+				rtn_status = spi_nand_dma_program_load(write_addr, oob_len, speed_mode);
+				if(rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR) {
+					SPI_NAND_Flash_Clear_Read_Cache_Data();
+					/* Switch to manual mode*/
+					_SPI_NAND_ENABLE_MANUAL_MODE();
+					return (rtn_status);
+				}
+			}
+			else
+			{
+				spi_nand_protocol_program_load(write_addr, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)), speed_mode);
 			}
 						
 			/*	Enable write_to flash */
@@ -2257,19 +2757,20 @@
 			/*	Enable write_to flash */
 			spi_nand_protocol_write_enable();		
 			
-			/* Proram data into buffer of SPI NAND chip */
-			switch( speed_mode )
-			{						
-				case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
-					spi_nand_protocol_program_load_single_speed(  0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
-					break;
-					
-				case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
-					spi_nand_protocol_program_load_quad_speed(  0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
-					break;	
-
-				default:
-					break;
+			if( _spi_dma_mode ==1  )
+			{
+				rtn_status = spi_nand_dma_program_load(write_addr, oob_len, speed_mode);
+				if(rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR) {
+					SPI_NAND_Flash_Clear_Read_Cache_Data();
+					/* Switch to manual mode*/
+					_SPI_NAND_ENABLE_MANUAL_MODE();
+					return (rtn_status);
+				}
+			}
+			else
+			{
+				/* Proram data into buffer of SPI NAND chip */
+				spi_nand_protocol_program_load(write_addr, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)), speed_mode);
 			}
 		}		
 
@@ -2456,15 +2957,15 @@
 	
 #if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
 		memset(oob_buf, 0xff, _SPI_NAND_OOB_SIZE);	
-			addr_offset_in_block = (write_addr %(ptr_dev_info_t->erase_size) );
-			logical_block = (write_addr / (ptr_dev_info_t->erase_size));
-			physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
-			physical_dst_addr = (physical_block * (ptr_dev_info_t->erase_size))+ addr_offset_in_block;
-	
-			if( physical_block != logical_block)
-			{			
-				_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
-			}
+		addr_offset_in_block = (write_addr %(ptr_dev_info_t->erase_size) );
+		logical_block = (write_addr / (ptr_dev_info_t->erase_size));
+		physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
+		physical_dst_addr = (physical_block * (ptr_dev_info_t->erase_size))+ addr_offset_in_block;
+
+		if( physical_block != logical_block)
+		{
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
+		}
 #endif
 	
 		/* Caculate page number */
@@ -2489,7 +2990,7 @@
 		
        if(_SPI_NAND_TEST_FLAG == 0)		
        {
-		rtn_status = spi_nand_write_page(page_number, addr_offset, &(ptr_buf[len - remain_len]), data_len, 0, &oob_buf[0], _SPI_NAND_OOB_SIZE , speed_mode);
+		rtn_status = spi_nand_write_page(page_number, addr_offset, &(ptr_buf[len - remain_len]), data_len, 0, &oob_buf[0], ptr_dev_info_t->oob_size , speed_mode);
        }
 	   else
 	   {
@@ -2503,7 +3004,6 @@
             {            	
                 _SPI_NAND_PRINTF("Update BMT success\n");
 				rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
-
             }
             else
             {
@@ -2559,7 +3059,7 @@
 #endif				
 			
 	
-			spi_nand_read_page(page_number, speed_mode);
+			rtn_status = spi_nand_read_page(page_number, speed_mode);
 			
 		_SPI_NAND_SEMAPHORE_UNLOCK();
 						
@@ -2653,7 +3153,7 @@
 		spi_nand_read_page(page_number, speed_mode);
 		
 		/* 3. Retrieve the request data */
-		if( (data_offset + remain_len) < _SPI_NAND_PAGE_SIZE ) 
+		if( (data_offset + remain_len) < ptr_dev_info_t->page_size )
 			{				
 			memcpy( &ptr_rtn_buf[len - remain_len], &_current_cache_page_data[data_offset], (sizeof(unsigned char)*remain_len) );
 			remain_len =0;			
@@ -2661,9 +3161,9 @@
 		}
 		else			
 		{
-			memcpy( &ptr_rtn_buf[len - remain_len], &_current_cache_page_data[data_offset], (sizeof(unsigned char)*(_SPI_NAND_PAGE_SIZE- data_offset)));
-			remain_len -= (_SPI_NAND_PAGE_SIZE- data_offset);
-			read_addr += (_SPI_NAND_PAGE_SIZE- data_offset);
+			memcpy( &ptr_rtn_buf[len - remain_len], &_current_cache_page_data[data_offset], (sizeof(unsigned char)*(ptr_dev_info_t->page_size - data_offset)));
+			remain_len -= (ptr_dev_info_t->page_size - data_offset);
+			read_addr += (ptr_dev_info_t->page_size - data_offset);
 		}
 	}			
 	_SPI_NAND_SEMAPHORE_UNLOCK();
@@ -2696,8 +3196,32 @@
 
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"SPI NAND Chip Init : Unlock all block and Enable Quad Mode\n"); 
 
-	if( ((ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) || \
-		((ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MXIC) )
+	if(((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UAYIG)) ||
+		((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UBYIG)) ||
+		((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG)) ||
+		((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG)) ||
+		((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG)) ||
+		((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F4GQ4UBYIG)) ||
+		((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F4GQ4UCYIG)))
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC1;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+
+
+		/* 2. Enable Qual mode */
+		spi_nand_protocol_get_status_reg_2(&feature);
+		feature |= 0x1;
+		spi_nand_protocol_set_status_reg_2(feature);
+
+		spi_nand_protocol_get_status_reg_2(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After enable qual mode setup, the status register2 =0x%x\n", feature);
+	}
+	else if((ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MXIC)
 	{
 		/* 1. Unlock All block */
 		spi_nand_protocol_get_status_reg_1(&feature);
@@ -2718,6 +3242,11 @@
 	}
 	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_WINBOND)
 	{			
+		if(((ptr_device_t->feature) & SPI_NAND_FLASH_DIE_SELECT_1_HAVE)) {
+			_die_id = 0x00;
+			spi_nand_protocol_die_select_1(_die_id);
+		}
+
 		/* Enable to modify the status regsiter 1 */
 		feature = 0x58;
 		spi_nand_protocol_set_status_reg_2(feature);
@@ -2733,10 +3262,10 @@
 		spi_nand_protocol_get_status_reg_1(&feature);
 
 		/* Unlock all block for Die_1 */
-		if(((ptr_device_t->feature) & SPI_NAND_FLASH_DIE_SELECT_HAVE))
+		if(((ptr_device_t->feature) & SPI_NAND_FLASH_DIE_SELECT_1_HAVE))
 		{
 			_die_id = 0x01;
-			spi_nand_protocol_die_select(_die_id);
+			spi_nand_protocol_die_select_1(_die_id);
 
 			/* Enable to modify the status regsiter 1 */
 			feature = 0x58;
@@ -2755,17 +3284,19 @@
 
 		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);					
 	}
-	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ESMT)
+	else if(((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ESMT) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_F50L512M41A)) ||
+			((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ESMT) && (ptr_device_t->dev_id == _SPI_NAND_DEVICE_ID_F50L1G41A0)))
 	{
 		/* 1. Unlock All block */
 		spi_nand_protocol_get_status_reg_1(&feature);
-		feature &= 0xC1;
+		feature &= 0xC7;
 		spi_nand_protocol_set_status_reg_1(feature);
 
 		spi_nand_protocol_get_status_reg_1(&feature);
 		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);						
 	}
-	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ZENTEL) 
+	else if(((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ZENTEL) && (ptr_device_t->device_size == _SPI_NAND_DEVICE_ID_A5U12A21ASC)) ||
+			((ptr_device_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ZENTEL) && (ptr_device_t->device_size == _SPI_NAND_DEVICE_ID_A5U1GA21BWS)))
 	{
 		/* 1. Unlock All block */
 		spi_nand_protocol_get_status_reg_1(&feature);
@@ -2779,7 +3310,7 @@
 	{
 		/* 1. Unlock All block */
 		spi_nand_protocol_get_status_reg_1(&feature);
-		feature &= 0xC7;
+		feature &= 0xC1;
 		spi_nand_protocol_set_status_reg_1(feature);
 
 		spi_nand_protocol_get_status_reg_1(&feature);
@@ -2806,17 +3337,46 @@
 
 	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MICRON)
 	{
+		if(((ptr_device_t->feature) & SPI_NAND_FLASH_DIE_SELECT_2_HAVE)) {
+			_die_id = 0x00;
+			spi_nand_protocol_die_select_2(_die_id);
+		}
+
 		/* 1. Unlock All block */
 		spi_nand_protocol_get_status_reg_1(&feature);
 		feature &= 0x83;
 		spi_nand_protocol_set_status_reg_1(feature);
 
 		spi_nand_protocol_get_status_reg_1(&feature);
-		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"After Unlock all block setup, the status register1 =0x%x\n", feature);												
-	}
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"After Unlock all block setup, the status register1 =0x%x\n", feature);
 
+		/* Unlock all block for Die_1 */
+		if( ((ptr_device_t->feature) & SPI_NAND_FLASH_DIE_SELECT_2_HAVE) )
+		{
+			_die_id = 0x01;
+			spi_nand_protocol_die_select_2(_die_id);
 
+			/* 1. Unlock All block */
+			spi_nand_protocol_get_status_reg_1(&feature);
+			feature &= 0x83;
+			spi_nand_protocol_set_status_reg_1(feature);
 	
+			spi_nand_protocol_get_status_reg_1(&feature);
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"After Unlock all block setup, the die %d status register1 =0x%x\n", _die_id, feature);
+		}
+	}
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_HEYANG)
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC7;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		/* 2. Enable Qual mode */
+		spi_nand_protocol_get_status_reg_2(&feature);
+		feature |= 0x1;
+		spi_nand_protocol_set_status_reg_2(feature);
+	}
 	else
 	{
 		/* 1. Unlock All block */
@@ -2872,8 +3432,6 @@
 	spi_nand_protocol_read_id( (struct SPI_NAND_FLASH_INFO_T *)ptr_rtn_device_t );
 	_SPI_NAND_SEMAPHORE_UNLOCK();	
 	
-	_SPI_NAND_PRINTF("spi_nand_probe: mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_device_t->mfr_id, ptr_rtn_device_t->dev_id);
-
 	for ( i=0 ; i < (sizeof(spi_nand_flash_tables)/sizeof(struct SPI_NAND_FLASH_INFO_T)) ; i++) 
 	{
 		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"spi_nand_probe: table[%d]: mfr_id=0x%x, dev_id=0x%x\n", i, spi_nand_flash_tables[i].mfr_id, spi_nand_flash_tables[i].dev_id );
@@ -2887,10 +3445,20 @@
 			ptr_rtn_device_t->oob_size	  = spi_nand_flash_tables[i].oob_size;
 			ptr_rtn_device_t->dummy_mode  = spi_nand_flash_tables[i].dummy_mode;
 			ptr_rtn_device_t->read_mode	  = spi_nand_flash_tables[i].read_mode;
+			ptr_rtn_device_t->write_mode			= spi_nand_flash_tables[i].write_mode;
 			memcpy( &(ptr_rtn_device_t->ptr_name) , &(spi_nand_flash_tables[i].ptr_name), sizeof(ptr_rtn_device_t->ptr_name));
-			memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(spi_nand_flash_tables[i].oob_free_layout), sizeof(ptr_rtn_device_t->oob_free_layout));
+			if(isSpiNandAndCtrlECC) {
+				if(ptr_rtn_device_t->oob_size == _SPI_NAND_OOB_SIZE_64BYTE) {
+					memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(ooblayout_spi_controller_ecc_64), sizeof(ptr_rtn_device_t->oob_free_layout));
+				} else if(ptr_rtn_device_t->oob_size == _SPI_NAND_OOB_SIZE_128BYTE) {
+					memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(ooblayout_spi_controller_ecc_128), sizeof(ptr_rtn_device_t->oob_free_layout));
+				} else if(ptr_rtn_device_t->oob_size == _SPI_NAND_OOB_SIZE_256BYTE) {
+					memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(ooblayout_spi_controller_ecc_256), sizeof(ptr_rtn_device_t->oob_free_layout));
+				}
+			} else {
+				memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(spi_nand_flash_tables[i].oob_free_layout), sizeof(ptr_rtn_device_t->oob_free_layout));
+			}
 			ptr_rtn_device_t->feature = spi_nand_flash_tables[i].feature;
-			
 			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
 			break;
 		}
@@ -2903,8 +3471,6 @@
 		spi_nand_protocol_read_id_2( (struct SPI_NAND_FLASH_INFO_T *)ptr_rtn_device_t );
 		_SPI_NAND_SEMAPHORE_UNLOCK();	
 		
-		_SPI_NAND_PRINTF("spi_nand_probe: mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_device_t->mfr_id, ptr_rtn_device_t->dev_id);
-
 		for ( i=0 ; i < (sizeof(spi_nand_flash_tables)/sizeof(struct SPI_NAND_FLASH_INFO_T)) ; i++) 
 		{
 			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"spi_nand_probe: table[%d]: mfr_id=0x%x, dev_id=0x%x\n", i, spi_nand_flash_tables[i].mfr_id, spi_nand_flash_tables[i].dev_id );
@@ -2918,8 +3484,19 @@
 				ptr_rtn_device_t->oob_size	  = spi_nand_flash_tables[i].oob_size;
 				ptr_rtn_device_t->dummy_mode  = spi_nand_flash_tables[i].dummy_mode;
 				ptr_rtn_device_t->read_mode	  = spi_nand_flash_tables[i].read_mode;
+				ptr_rtn_device_t->write_mode			= spi_nand_flash_tables[i].write_mode;
 				memcpy( &(ptr_rtn_device_t->ptr_name) , &(spi_nand_flash_tables[i].ptr_name), sizeof(ptr_rtn_device_t->ptr_name));
-				memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(spi_nand_flash_tables[i].oob_free_layout), sizeof(ptr_rtn_device_t->oob_free_layout));
+				if(isSpiNandAndCtrlECC) {
+					if(ptr_rtn_device_t->oob_size == _SPI_NAND_OOB_SIZE_64BYTE) {
+						memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(ooblayout_spi_controller_ecc_64), sizeof(ptr_rtn_device_t->oob_free_layout));
+					} else if(ptr_rtn_device_t->oob_size == _SPI_NAND_OOB_SIZE_128BYTE) {
+						memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(ooblayout_spi_controller_ecc_128), sizeof(ptr_rtn_device_t->oob_free_layout));
+					} else if(ptr_rtn_device_t->oob_size == _SPI_NAND_OOB_SIZE_256BYTE) {
+						memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(ooblayout_spi_controller_ecc_256), sizeof(ptr_rtn_device_t->oob_free_layout));
+					}
+				} else {
+					memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(spi_nand_flash_tables[i].oob_free_layout), sizeof(ptr_rtn_device_t->oob_free_layout));
+				}
 				ptr_rtn_device_t->feature = spi_nand_flash_tables[i].feature;
 				
 				rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
@@ -2927,13 +3504,20 @@
 			}
 		}
 	}
-	
+
+	_SPI_NAND_PRINTF("spi_nand_probe: mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_device_t->mfr_id, ptr_rtn_device_t->dev_id);
 
 	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
 		_SPI_NAND_SEMAPHORE_LOCK();
 		spi_nand_manufacute_init(ptr_rtn_device_t);		
 		_SPI_NAND_SEMAPHORE_UNLOCK();	
+
+		if((ptr_rtn_device_t->write_mode == SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD) ||
+			(ptr_rtn_device_t->read_mode == SPI_NAND_FLASH_READ_SPEED_MODE_QUAD)) {
+			VPint(IOMUX_CONTROL1) |= (1 << 19);
+			VPint(IOMUX_CONTROL1) &= ~((1 << 18) | (1 << 11) | (1 << 8) | (1 << 7) | (1 << 3));
+		}
 	}	
 	
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_probe: end \n");
@@ -2959,32 +3543,43 @@
 
 
 int en7512_nand_exec_read_page(u32 page, u8* date, u8* oob)
-{ 
+{
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	unsigned long					spinand_spinlock_flags;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+	rtn_status = spi_nand_read_page(page, ptr_dev_info_t->read_mode);
+	_SPI_NAND_SEMAPHORE_UNLOCK();
 
-	if( spi_nand_read_page(page, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE) == SPI_NAND_FLASH_RTN_NO_ERROR)
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
 		/* Get data segment and oob segment  */
-		memcpy( date, &_current_cache_page_data[0], _SPI_NAND_PAGE_SIZE );
-		memcpy( oob,  &_current_cache_page_oob_mapping[0], _SPI_NAND_OOB_SIZE );		
+		memcpy( date, &_current_cache_page_data[0], ptr_dev_info_t->page_size );
+		memcpy( oob,  &_current_cache_page_oob_mapping[0], ptr_dev_info_t->oob_size );
 
 		return 0;
 	}
 	else
 	{
-		 _SPI_NAND_PRINTF( "en7512_nand_exec_read_page: Read Error\n");
+		 _SPI_NAND_PRINTF( "en7512_nand_exec_read_page: read error, page=0x%x\n", page);
 		return -1;
 	}
-	
 }
 int en7512_nand_check_block_bad(u32 offset, u32 bmt_block)
 {
+	u32								page_number;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	u8								def_bad_block_ECC[28];
+	unsigned long					spinand_spinlock_flags;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	SPI_NFI_CONF_T					spi_nfi_conf_t;
 
-	 u32							 page_number;
-	 struct SPI_NAND_FLASH_INFO_T	 *ptr_dev_info_t;
-	 
-	 ptr_dev_info_t  = _SPI_NAND_GET_DEVICE_INFO_PTR;	
+	ptr_dev_info_t  = _SPI_NAND_GET_DEVICE_INFO_PTR;
 
-	if(  (0xbc000000 <= offset) && (offset<= 0xbfffffff) )		/* Reserver address area for system */
+	if( (0xbc000000 <= offset) && (offset<= 0xbfffffff))		/* Reserver address area for system */
 	{
 		if( (offset & 0xbfc00000) == 0xbfc00000)
 		{
@@ -2996,43 +3591,95 @@
 		}
 	}	 
 
-	 /* Caculate page number */
-	 page_number = (offset / (ptr_dev_info_t->page_size));		 
-			 
-	 _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_check_block_bad: read_addr=0x%x, page_number=0x%x\n", offset, page_number);
-	 
-	 spi_nand_read_page(page_number, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
-	 
-	
-	 if(bmt_block){
-		 if(_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET] != 0xff){
-			 _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad block detected at page_addr 0x%x, oob_buf[%d] is 0x%x\n", page_number, BMT_BAD_BLOCK_INDEX_OFFSET,_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET]);
-			 return 1;
-		 }
-	 }
-	 else
-	 {
-		 if(_current_cache_page_oob_mapping[0] != 0xff)
-		 {
-			 _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad block detected at page_addr 0x%x, oob_buf[0] is 0x%x\n", page_number, _current_cache_page_oob_mapping[0]);
-			 return 1;
-		 }
-	 }
+	/* Caculate page number */
+	page_number = (offset / (ptr_dev_info_t->page_size));
 
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_check_block_bad: read_addr=0x%x, page_number=0x%x\n", offset, page_number);
 
-	return 0;  /* Good Block*/
+	SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+	rtn_status = spi_nand_read_page(page_number, ptr_dev_info_t->read_mode);
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	if (rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_check_block_bad return error, block:%d\n", offset/ptr_dev_info_t->erase_size);
+		return 1;
+	}
+
+	if(bmt_block){
+		if(_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET] != 0xff){
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad block detected at page_addr 0x%x, oob_buf[%d] is 0x%x\n", page_number, BMT_BAD_BLOCK_INDEX_OFFSET,_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET]);
+			return 1;
+		}
+	}
+	else
+	{
+		if(_current_cache_page_oob_mapping[0] != 0xff)
+		{
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad block detected at page_addr 0x%x, oob_buf[0] is 0x%x\n", page_number, _current_cache_page_oob_mapping[0]);
+			return 1;
+		}
+	}
+
+	if(_spi_dma_mode == 1) {
+		/* This is for check default bad block.
+		 * When DMA read with all ECC parity equal to 0xFF,
+		 * this will not generate read ECC error. So, it must
+		 * close DMA to check first OOB byte.
+		 */
+		_SPI_NAND_SEMAPHORE_LOCK();
+		SPI_NAND_Flash_Set_DmaMode(0);
+		SPI_NAND_Flash_Clear_Read_Cache_Data();
+		rtn_status = spi_nand_read_page(page_number, ptr_dev_info_t->read_mode);
+		SPI_NAND_Flash_Set_DmaMode(1);
+		SPI_NAND_Flash_Clear_Read_Cache_Data();
+		_SPI_NAND_SEMAPHORE_UNLOCK();
+
+		if (rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR) {
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_check_block_bad return error, block:%d\n", offset/ptr_dev_info_t->erase_size);
+			SPI_NAND_Flash_Set_DmaMode(1);
+			return 1;
+		}
+
+		memset(def_bad_block_ECC, 0xFF, sizeof(def_bad_block_ECC));
+		SPI_NFI_Get_Configure(&spi_nfi_conf_t);
 
+		if(memcmp(def_bad_block_ECC, &(_current_cache_page_oob_mapping[8]), (spi_nfi_conf_t.spare_size_t - spi_nfi_conf_t.fdm_num)) == 0) {
+			if(bmt_block) {
+				if(_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET] != 0xff) {
+					_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "DMA close, Bad block detected at page_addr 0x%x, oob_buf[%d] is 0x%x\n", page_number, BMT_BAD_BLOCK_INDEX_OFFSET,_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET]);
+					return 1;
+				}
+			} else {
+				if(_current_cache_page_oob_mapping[0] != 0xff) {
+					_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "DMA close, Bad block detected at page_addr 0x%x, oob_buf[0] is 0x%x\n", page_number, _current_cache_page_oob_mapping[0]);
+					return 1;
+				}
+			}
+		}
+	}
+
+	return 0;  /* Good Block*/
 }
 int en7512_nand_erase(u32 offset)
 {
-
 	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	unsigned long					spinand_spinlock_flags;
 	
 	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;   
 
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_erase: offset =0x%x, erase_size=0x%x\n", offset, (ptr_dev_info_t->erase_size));
 
-	if(spi_nand_erase_block( (offset / (ptr_dev_info_t->erase_size)) )== SPI_NAND_FLASH_RTN_NO_ERROR)
+	SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+	rtn_status = spi_nand_erase_block((offset / (ptr_dev_info_t->erase_size)));
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
 		return 0;		
 	}
@@ -3049,6 +3696,7 @@
 	u8 buf[8];
 	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	unsigned long					spinand_spinlock_flags;
 
 	 ptr_dev_info_t  = _SPI_NAND_GET_DEVICE_INFO_PTR;	
 
@@ -3071,9 +3719,10 @@
 
 	_SPI_NAND_PRINTF("en7512_nand_mark_badblock: page_num=0x%x\n", page_number);
 
-	rtn_status = spi_nand_write_page(page_number, 0, NULL, 0, 0, &buf[0], 8 , SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+	_SPI_NAND_SEMAPHORE_LOCK();
+	rtn_status = spi_nand_write_page(page_number, 0, NULL, 0, 0, &buf[0], 8, ptr_dev_info_t->write_mode);
+	_SPI_NAND_SEMAPHORE_UNLOCK();
 	
-
 	if( rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
 		return 0;
@@ -3089,10 +3738,16 @@
 {
 
 	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	unsigned long					spinand_spinlock_flags;
+
+	ptr_dev_info_t  = _SPI_NAND_GET_DEVICE_INFO_PTR;
 
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_exec_write_page: page=0x%x\n", page);
-	
-	rtn_status = spi_nand_write_page(page, 0, dat, _SPI_NAND_PAGE_SIZE, 0, oob, _SPI_NAND_OOB_SIZE , SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+	rtn_status = spi_nand_write_page(page, 0, dat, ptr_dev_info_t->page_size, 0, oob, ptr_dev_info_t->oob_size , ptr_dev_info_t->write_mode);
+	_SPI_NAND_SEMAPHORE_UNLOCK();
 
 	if( rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
@@ -3106,7 +3761,6 @@
 
 
 u32 maximum_bmt_block_count = 0;
-
 int calc_bmt_pool_size(struct mtd_info *mtd)
 {
 	struct nand_chip *nand = mtd->priv;
@@ -3118,7 +3772,6 @@
     u16 valid_block_num = 0;
     u16 need_valid_block_num = total_block * POOL_GOOD_BLOCK_PERCENT;
 
-
 	_SPI_NAND_PRINTF("calc_bmt_pool_size : need_valid_block_num=0x%x, total_block=0x%x\n",need_valid_block_num, total_block);
 
 	maximum_bmt_block_count = total_block * MAX_BMT_SIZE_PERCENTAGE;
@@ -3127,28 +3780,23 @@
 	maximum_bmt_block_count = total_block * MAX_BMT_SIZE_PERCENTAGE_CT;
 #endif
 
-	
-    for(;last_block > 0; --last_block)
-    {
-        if(en7512_nand_check_block_bad(last_block * block_size, BAD_BLOCK_RAW))
-        {
-            continue;
-    
-        }
-        else
-        {
-            valid_block_num++;
-            if(valid_block_num == need_valid_block_num)
-            {
-                break;
-            }
-
-        }
-
-    }
+	for(;last_block > 0; --last_block)
+	{
+		if(en7512_nand_check_block_bad(last_block * block_size, BAD_BLOCK_RAW))
+		{
+			continue;
+		}
+		else
+		{
+			valid_block_num++;
+			if(valid_block_num == need_valid_block_num)
+			{
+				break;
+			}
+		}
+	}
 
-    return (total_block - last_block);
-    
+	return (total_block - last_block);
 }
 
 
@@ -3178,13 +3826,21 @@
 SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Init(u32 rom_base)
 {
 	unsigned long val;
+	SPI_NFI_CONF_T			spi_nfi_conf_t;
+	SPI_ECC_ENCODE_CONF_T	encode_conf_t;
+	SPI_ECC_DECODE_CONF_T	decode_conf_t;
+	int						spi_controller_clk;
+	int						sec_num;
 	
 	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_PROBE_ERROR;	
 	
 	/* 1. set SFC Clock to 25MHZ */
-	val = VPint(_SPI_FREQUENCY_ADJUST_REG);
-	val |= 0xa01;
-	VPint(_SPI_FREQUENCY_ADJUST_REG) = val;
+	spi_controller_clk = 25;
+	if(isEN7526c) {
+		spi_nand_set_clock_speed(400/(spi_controller_clk * 2));
+	} else {
+		spi_nand_set_clock_speed(500/(spi_controller_clk * 2));
+	}
 	
 	/* 2. Enable Manual Mode */
 	_SPI_NAND_ENABLE_MANUAL_MODE();	
@@ -3197,8 +3853,59 @@
 		_SPI_NAND_PRINTF("SPI NAND Flash Detected Error !\n");
 	}
 	else
-	{		
-		_SPI_NAND_PRINTF("Dected SPI NAND Flash : %s, Flash Size=0x%x\n", _current_flash_info_t.ptr_name,  _current_flash_info_t.device_size);
+	{
+		/* for 32bytes alignment */
+		dma_read_page = tmp_dma_read_page + (CACHE_LINE_SIZE - (((u32)tmp_dma_read_page) % CACHE_LINE_SIZE));
+		dma_write_page = tmp_dma_write_page + (CACHE_LINE_SIZE - (((u32)tmp_dma_write_page) % CACHE_LINE_SIZE));
+		/* flush cache_page */
+		dma_cache_inv(dma_read_page, _SPI_NAND_CACHE_SIZE);
+		dma_cache_inv(dma_write_page, _SPI_NAND_CACHE_SIZE);
+
+		if(isSpiNandAndCtrlECC) {
+			/* Init DMA */
+			SPI_NFI_Init();
+			SPI_NFI_Get_Configure(&spi_nfi_conf_t);
+			spi_nfi_conf_t.auto_fdm_t			= SPI_NFI_CON_AUTO_FDM_Enable;
+			spi_nfi_conf_t.hw_ecc_t 			= SPI_NFI_CON_HW_ECC_Enable;
+			spi_nfi_conf_t.dma_burst_t			= SPI_NFI_CON_DMA_BURST_Enable;
+			spi_nfi_conf_t.fdm_num				= 8;
+			spi_nfi_conf_t.fdm_ecc_num			= 8;
+			spi_nfi_conf_t.spare_size_t 		= SPI_NFI_CONF_SPARE_SIZE_16BYTE;
+			spi_nfi_conf_t.page_size_t			= _current_flash_info_t.page_size;
+			if(_current_flash_info_t.page_size == _SPI_NAND_PAGE_SIZE_2KBYTE) {
+				sec_num = 4;
+			} else if(_current_flash_info_t.page_size == _SPI_NAND_PAGE_SIZE_4KBYTE) {
+				sec_num = 8;
+			} else {
+				sec_num = 1;
+			}
+			spi_nfi_conf_t.sec_num				= sec_num;
+			spi_nfi_conf_t.cus_sec_size_en_t	= SPI_NFI_CONF_CUS_SEC_SIZE_Disable;
+			spi_nfi_conf_t.sec_size 			= 0;
+			SPI_NFI_Set_Configure(&spi_nfi_conf_t);
+
+			/* Set controller to DMA mode */
+			SPI_NAND_Flash_Set_DmaMode(1);
+
+			/* Init Decode, Encode */
+			SPI_ECC_Encode_Init();
+			SPI_ECC_Decode_Init();
+
+			/* Setup Encode */
+			SPI_ECC_Encode_Get_Configure(&encode_conf_t);
+			encode_conf_t.encode_en 			= SPI_ECC_ENCODE_ENABLE;
+			encode_conf_t.encode_ecc_abiliry	= SPI_ECC_ENCODE_ABILITY_4BITS;
+			encode_conf_t.encode_block_size 	= 512 + spi_nfi_conf_t.fdm_ecc_num;
+			SPI_ECC_Encode_Set_Configure(&encode_conf_t);
+
+			/* Setup Decode */
+			SPI_ECC_Decode_Get_Configure(&decode_conf_t);
+			decode_conf_t.decode_en 			= SPI_ECC_DECODE_ENABLE;
+			decode_conf_t.decode_ecc_abiliry	= SPI_ECC_DECODE_ABILITY_4BITS;
+			decode_conf_t.decode_block_size 	= (((spi_nfi_conf_t.fdm_ecc_num) + 512) * 8) + ((decode_conf_t.decode_ecc_abiliry) * 13);
+			SPI_ECC_Decode_Set_Configure(&decode_conf_t);
+		}
+		_SPI_NAND_PRINTF("Detected SPI NAND Flash : %s, Flash Size=0x%x\n", _current_flash_info_t.ptr_name,  _current_flash_info_t.device_size);
 		rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
 	}
 
@@ -3399,7 +4106,7 @@
 	unsigned long dword;
 	size_t retlen;
 	int ret = 0, i;
-	
+
 	ret = spi_nand_mtd->read( spi_nand_mtd, (loff_t)addr, 4, &retlen, data);
 
 	if (ret != 0)
@@ -3549,6 +4256,7 @@
 #define ECC_SOFT
 
 #define SPI_NAND_PROCNAME				"driver/spi_nand_debug"
+#define SPI_NAND_TEST					"driver/spi_nand_test"
 
 
 
@@ -3635,6 +4343,18 @@
 	return 0;
 }
 
+void SPI_NAND_Flash_Set_DmaMode( u32 input )
+{
+	_spi_dma_mode = input;
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "SPI_NAND_Flash_Set_DmaMode : dma_mode =%d\n", _spi_dma_mode);
+}
+
+void SPI_NAND_Flash_Get_DmaMode( u32 *val )
+{
+	*val = _spi_dma_mode;
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "SPI_NAND_Flash_Get_DmaMode : dma_mode =%d\n", _spi_dma_mode);
+}
+
 /*
  * spinand_read_status- send command 0xf to the SPI Nand status register
  * Description:
@@ -3707,40 +4427,143 @@
  */
 static int spinand_enable_ecc(struct spi_device *spi_nand)
 {
-        int retval;
-        u8 otp = 0;
+    int retval;
+    u8 otp = 0;
+	struct SPI_NAND_FLASH_INFO_T *ptr_dev_info_t;u8 die_num;
+	int i;
+
+	ptr_dev_info_t = _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_1_HAVE)) {
+		die_num = (ptr_dev_info_t->device_size / ptr_dev_info_t->page_size) >> 16;
+
+		for(i = 0; i < die_num; i++) {
+			spi_nand_protocol_die_select_1(i);
+
+			retval = spinand_get_otp(spi_nand, &otp);
+	        if (retval < 0) {
+				return retval;
+	        }
+
+	        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+				continue;
+	        }
+			otp |= OTP_ECC_MASK;
+			retval = spinand_set_otp(spi_nand, &otp);
+			if (retval < 0) {
+				return retval;
+			}
+		}
+	} else if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_2_HAVE)) {
+		die_num = (ptr_dev_info_t->device_size / ptr_dev_info_t->page_size) >> 17;
+
+		for(i = 0; i < die_num; i++) {
+			spi_nand_protocol_die_select_2(i);
 
+			retval = spinand_get_otp(spi_nand, &otp);
+	        if (retval < 0) {
+				return retval;
+	        }
+
+	        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+				continue;
+	        }
+			otp |= OTP_ECC_MASK;
+			retval = spinand_set_otp(spi_nand, &otp);
+			if (retval < 0) {
+				return retval;
+			}
+		}
+	} else {
         retval = spinand_get_otp(spi_nand, &otp);
-        if (retval < 0)
-                return retval;
+        if (retval < 0) {
+			return retval;
+        }
 
-        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK)
-                return 0;
-        otp |= OTP_ECC_MASK;
-        retval = spinand_set_otp(spi_nand, &otp);
-        if (retval < 0)
-                return retval;
-        return spinand_get_otp(spi_nand, &otp);
+        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+			_ondie_ecc_flag = 1;
+			return 0;
+        }
+		otp |= OTP_ECC_MASK;
+		retval = spinand_set_otp(spi_nand, &otp);
+		if (retval < 0) {
+			return retval;
+		}
+	}
+
+	_ondie_ecc_flag = 1;
+
+    return spinand_get_otp(spi_nand, &otp);
 }
 #endif
 
 static int spinand_disable_ecc(struct spi_device *spi_nand)
 {
-        int retval;
-        u8 otp = 0;
+    int retval;
+    u8 otp = 0;
+	struct SPI_NAND_FLASH_INFO_T *ptr_dev_info_t;
+	u8 die_num;
+	int i;
 
-        retval = spinand_get_otp(spi_nand, &otp);
-        if (retval < 0)
-                return retval;
+	ptr_dev_info_t = _SPI_NAND_GET_DEVICE_INFO_PTR;
 
-        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
-                otp &= ~OTP_ECC_MASK;
-                retval = spinand_set_otp(spi_nand, &otp);
-                if (retval < 0)
-                        return retval;
-                return spinand_get_otp(spi_nand, &otp);
-        }
-        return 0;
+	if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_1_HAVE)) {
+		die_num = (ptr_dev_info_t->device_size / ptr_dev_info_t->page_size) >> 16;
+
+		for(i = 0; i < die_num; i++) {
+			spi_nand_protocol_die_select_1(i);
+
+			retval = spinand_get_otp(spi_nand, &otp);
+			if (retval < 0) {
+				return retval;
+			}
+
+			if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+				otp &= ~OTP_ECC_MASK;
+				retval = spinand_set_otp(spi_nand, &otp);
+				if (retval < 0) {
+					return retval;
+				}
+			}
+		}
+	} else if(((ptr_dev_info_t->feature) & SPI_NAND_FLASH_DIE_SELECT_2_HAVE)) {
+		die_num = (ptr_dev_info_t->device_size / ptr_dev_info_t->page_size) >> 17;
+
+		for(i = 0; i < die_num; i++) {
+			spi_nand_protocol_die_select_2(i);
+
+			retval = spinand_get_otp(spi_nand, &otp);
+			if (retval < 0) {
+				return retval;
+			}
+
+			if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+				otp &= ~OTP_ECC_MASK;
+				retval = spinand_set_otp(spi_nand, &otp);
+				if (retval < 0) {
+					return retval;
+				}
+			}
+		}
+	} else {
+		retval = spinand_get_otp(spi_nand, &otp);
+		if (retval < 0)
+			return retval;
+
+		if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+			otp &= ~OTP_ECC_MASK;
+			retval = spinand_set_otp(spi_nand, &otp);
+			if (retval < 0) {
+				return retval;
+			}
+			_ondie_ecc_flag = 0;
+			return spinand_get_otp(spi_nand, &otp);
+		}
+	}
+
+	_ondie_ecc_flag = 0;
+
+	return 0;
 }
 
 /**
@@ -3778,7 +4601,7 @@
 	 unsigned int ret;
 	 u8			status;
 		
-      spi_nand_protocol_read_from_cache_single_speed(byte_id, len, rbuf, SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND);
+      spi_nand_protocol_read_from_cache(byte_id, len, rbuf, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE, SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND);
       
         while (1) {
                 ret = spinand_read_status(spi_nand, &status);
@@ -3815,7 +4638,7 @@
 
 	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
 
-	rtn_status = spi_nand_read_internal( (((ptr_dev_info_t->page_size)*page_id)+offset), len, rbuf, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+	rtn_status = spi_nand_read_internal((((ptr_dev_info_t->page_size)*page_id)+offset), len, rbuf, ptr_dev_info_t->read_mode);
 
 	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
@@ -3843,7 +4666,7 @@
 static int spinand_program_data_to_cache(struct spi_device *spi_nand,
                 u32 page_id, u32 byte_id, u32 len, u8 *wbuf)
 {
-        return spi_nand_protocol_program_load_single_speed(byte_id, wbuf, len);
+        return spi_nand_protocol_program_load(byte_id, wbuf, len, SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
 }
 
 /**
@@ -3890,7 +4713,7 @@
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_program_page: _current_cache_page_oob_mapping: state->oob_buf_len=0x%x, state->oob_buf=\n", (state->oob_buf_len));
 	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &(state->oob_buf[0]), (state->oob_buf_len));
 	
-	rtn_status = spi_nand_write_page_internal(page_id, (state->buf_idx), &state->buf[(state->buf_idx)], (state->buf_len),  0, (&state->oob_buf[0]), (state->oob_buf_len), SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+	rtn_status = spi_nand_write_page_internal(page_id, (state->buf_idx), &state->buf[(state->buf_idx)], (state->buf_len),  0, (&state->oob_buf[0]), (state->oob_buf_len), ptr_dev_info_t->write_mode);
 
 	if( rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
 	{
@@ -4082,13 +4905,14 @@
 	struct spinand_state *state = mtd_to_state(mtd);			
 	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
 
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
 
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_write_page]: enter, page=0x%x \n", page);	
 
 	memset((state->oob_buf), 0xff, MAX_USE_OOB_SIZE);
 	memcpy(&(state->oob_buf)[LINUX_USE_OOB_START_OFFSET], chip->oob_poi, MAX_LINUX_USE_OOB_SIZE);
 	
-	rtn_status = spi_nand_write_page_internal(page, 0, buf, (ptr_dev_info_t->page_size),  0, (state->oob_buf), MAX_LINUX_USE_OOB_SIZE, SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+	rtn_status = spi_nand_write_page_internal(page, 0, buf, (ptr_dev_info_t->page_size),  0, (state->oob_buf), MAX_LINUX_USE_OOB_SIZE, ptr_dev_info_t->write_mode);
 	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR ) 
 	{
 		return 0;
@@ -4105,14 +4929,16 @@
 
 	struct spinand_state *state = mtd_to_state(mtd);			
 	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
 
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
 
 	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_write_oob]: enter, page=0x%x \n", page);	
 
 	memset(state->oob_buf, 0xff, MAX_USE_OOB_SIZE);
 	memcpy(&(state->oob_buf)[LINUX_USE_OOB_START_OFFSET], chip->oob_poi, MAX_LINUX_USE_OOB_SIZE);
 
-	rtn_status = spi_nand_write_page_internal(page, 0, NULL, 0,  0, (&state->oob_buf[0]), MAX_LINUX_USE_OOB_SIZE, SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+	rtn_status = spi_nand_write_page_internal(page, 0, NULL, 0,  0, (&state->oob_buf[0]), MAX_LINUX_USE_OOB_SIZE, ptr_dev_info_t->write_mode);
 
 	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR ) 
 	{
@@ -4267,7 +5093,7 @@
 			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_READ0 \n");	
 
 			state->buf_idx = column;
-			spi_nand_read_page_internal(page, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+			spi_nand_read_page_internal(page, ptr_dev_info_t->read_mode);
 			
 			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"[spinand_cmdfunc]: NAND_CMD_READ0/1, End\n");
 
@@ -4276,7 +5102,7 @@
 	case NAND_CMD_READOOB:
  			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_READOOB, page=0x%x \n", page);
 	        state->buf_idx = column + (ptr_dev_info_t->page_size);
-	        spi_nand_read_page_internal(page, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+	        spi_nand_read_page_internal(page, ptr_dev_info_t->read_mode);
 			
 	        break;
 	case NAND_CMD_RNDOUT:
@@ -4462,6 +5288,15 @@
     chip->ecc.layout 		= &spinand_oob_64;
     chip->ecc.read_page		= spinand_read_page_hwecc;
     chip->ecc.write_page 	= spinand_write_page_hwecc;
+	if(_spi_dma_mode == 1) {
+		/* Disable OnDie ECC */
+		if (spinand_disable_ecc(spi_nand) < 0)
+			pr_info("%s: disable ecc failed!\n", __func__);
+	} else {
+		/* Enable OnDie ECC */
+		if (spinand_enable_ecc(spi_nand) < 0)
+			pr_info("%s: enable ecc failed!\n", __func__);
+	}
 #else
     chip->ecc.mode  = NAND_ECC_SOFT;
     if (spinand_disable_ecc(spi_nand) < 0)
@@ -4519,8 +5354,6 @@
 
 #if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
 
-				_SPI_NAND_SEMAPHORE_LOCK();
-
 				bmt_pool_size = calc_bmt_pool_size(mtd);
 				if(bmt_pool_size > maximum_bmt_block_count)
 				{
@@ -4535,7 +5368,6 @@
 					if ( !(g_bmt = init_bmt(mtd, bmt_pool_size)) )
 					{
 						_SPI_NAND_PRINTF("Error: init bmt failed \n");
-						_SPI_NAND_SEMAPHORE_UNLOCK();
 						return -1;
 					}
 				}
@@ -4545,7 +5377,6 @@
 					if ( !(g_bbt = start_init_bbt()) )
 					{
 						_SPI_NAND_PRINTF("Error: init bbt failed \n");
-							_SPI_NAND_SEMAPHORE_UNLOCK();
 						return -1;
 					}
 				}
@@ -4553,21 +5384,17 @@
 				if(write_bbt_or_bmt_to_flash() != 0)
 				{				
 					_SPI_NAND_PRINTF("Error: save bbt or bmt to nand failed \n");
-					_SPI_NAND_SEMAPHORE_UNLOCK();
 					return -1;
 				}
 				
 				if(create_badblock_table_by_bbt())
 				{
 					_SPI_NAND_PRINTF("Error: create bad block table failed \n");
-					_SPI_NAND_SEMAPHORE_UNLOCK();
 					return -1;
 				}
 	
 				_SPI_NAND_PRINTF("BMT & BBT Init Success \n");
 
-				_SPI_NAND_SEMAPHORE_UNLOCK();				
-
 #ifdef TCSUPPORT_CT_PON
 				nand_flash_avalable_size = chip->chipsize - (chip->chipsize * MAX_BMT_SIZE_PERCENTAGE_CT);
 				mtd->size = nand_flash_avalable_size;
@@ -4661,6 +5488,138 @@
 
 }
 
+static int write_test(void *arg)
+{
+	struct _SPI_NAND_FLASH_RW_TEST_T param;
+	struct SPI_NAND_FLASH_INFO_T	 *ptr_dev_info_t;
+	u32								 ptr_rtn_len;
+	u8 buf[64], read_buf[64];
+	int i;
+#if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
+	int cpu = smp_processor_id();
+	int vpe = cpu_data[cpu].vpe_id;
+#else
+	int cpu = 0;
+	int vpe = 0;
+#endif
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	memcpy(&param, arg, sizeof(struct _SPI_NAND_FLASH_RW_TEST_T));
+	_SPI_NAND_PRINTF("write_test: run at vpe:%d, cpu:%d\n", vpe, cpu);
+	_SPI_NAND_PRINTF("write_test: times=%d, block_idx=%d\n", param.times, param.block_idx);
+
+	while (!kthread_should_stop() && param.times > 0) {
+		if(param.times % 10 == 0)
+			printk("write_test:%d\n", param.times);
+		msleep(1);
+		param.times--;
+		get_random_bytes(buf, sizeof(buf));
+		SPI_NAND_Flash_Erase(param.block_idx * ptr_dev_info_t->erase_size, sizeof(buf));
+    	SPI_NAND_Flash_Write_Nbyte(param.block_idx * ptr_dev_info_t->erase_size, sizeof(buf), &ptr_rtn_len, buf, ptr_dev_info_t->write_mode);
+		SPI_NAND_Flash_Read_NByte(param.block_idx * ptr_dev_info_t->erase_size, sizeof(read_buf), &ptr_rtn_len, read_buf, ptr_dev_info_t->read_mode);
+
+		if(memcmp(buf, read_buf, sizeof(buf)) != 0) {
+			_SPI_NAND_PRINTF("write fail\n");
+			return -1;
+		}
+	}
+
+	_SPI_NAND_PRINTF("write done\n");
+
+	return 0;
+}
+
+static int read_test(void *arg)
+{
+	struct _SPI_NAND_FLASH_RW_TEST_T param;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	u32								 ptr_rtn_len;
+	u8 buf[64];
+#if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
+	int cpu = smp_processor_id();
+	int vpe = cpu_data[cpu].vpe_id;
+#else
+	int cpu = 0;
+	int vpe = 0;
+#endif
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	memcpy(&param, arg, sizeof(struct _SPI_NAND_FLASH_RW_TEST_T));
+	_SPI_NAND_PRINTF("read_test: run at vpe:%d, cpu:%d\n", vpe, cpu);
+	_SPI_NAND_PRINTF("read_test: times=%d, block_idx=%d\n", param.times, param.block_idx);
+
+	memset(buf, 0xaa, sizeof(buf));
+
+	while (!kthread_should_stop() && param.times > 0) {
+		if(param.times % 10 == 0)
+			_SPI_NAND_PRINTF("read_test:%d\n", param.times);
+		msleep(1);
+		param.times--;
+		SPI_NAND_Flash_Read_NByte(param.block_idx * ptr_dev_info_t->erase_size, sizeof(buf), &ptr_rtn_len, buf, ptr_dev_info_t->read_mode);
+	}
+
+	_SPI_NAND_PRINTF("read done\n");
+
+	return 0;
+}
+
+static int spi_nand_proc_test_write(struct file* file, const char* buffer,
+	unsigned long count, void *data)
+{
+	char 							buf[64], cmd[32];
+	u32 							arg1, arg2;
+	struct task_struct 				*thread;
+	u32								ptr_rtn_len;
+	u32								idx;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	unsigned int cpu;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	if (copy_from_user(buf, buffer, count)) {
+		return -EFAULT;
+	}
+
+	buf[count] = '\0';
+
+	sscanf(buf, "%s %d %d", cmd, &arg1, &arg2) ;
+
+	_SPI_NAND_PRINTF("cmd:%s, arg1=%u, arg2=%u\n", cmd, arg1, arg2);
+
+	if (!strcmp(cmd, "rw_test")) {
+		rw_test_param.times = arg1;
+		rw_test_param.block_idx = arg2;
+
+		thread = kthread_create(write_test, (void *)&rw_test_param, "write_test");
+		kthread_bind(thread, 3);
+		wake_up_process(thread);
+		thread = kthread_create(read_test, (void *)&rw_test_param, "read_test");
+		kthread_bind(thread, 2);
+		wake_up_process(thread);
+ 	} else if (!strcmp(cmd, "read")) {
+		SPI_NAND_Flash_Read_NByte(arg1, ptr_dev_info_t->page_size, &ptr_rtn_len, _current_cache_page_data, ptr_dev_info_t->read_mode);
+		printk("read data:\n");
+		for(idx = 0; idx < ptr_dev_info_t->page_size; idx++) {
+			if((idx % 8 == 0) && (idx != 0)) {
+				printk("  ");
+			}
+			if(idx % 16 == 0)	{
+				printk("\n%08x: ", idx);
+			}
+			printk("%02x ", _current_cache_page_data[idx]);
+		}
+	    printk("\n\n");
+ 	} else if (!strcmp(cmd, "erase")) {
+		SPI_NAND_Flash_Erase(arg1 * ptr_dev_info_t->erase_size, ptr_dev_info_t->erase_size);
+ 	} else {
+		_SPI_NAND_PRINTF("input not defined.\n");
+	}
+
+	return count;
+
+}
 
 
 static struct mtd_info *spi_nand_probe_kernel(struct map_info *map)
@@ -4725,6 +5684,14 @@
 		entry->read_proc = spi_nand_proc_read;
 		entry->write_proc = spi_nand_proc_write;
 
+		entry = create_proc_entry(SPI_NAND_TEST, 0666, NULL);
+		if (entry == NULL)
+		{
+			_SPI_NAND_PRINTF("SPI NAND  unable to create /proc entry\n");
+			return -ENOMEM;
+		}
+		entry->write_proc = spi_nand_proc_test_write;
+
 		
 		return 0;
 	}
@@ -4740,6 +5707,7 @@
 		unregister_mtd_chip_driver(&spi_nand_chipdrv);
 
 		remove_proc_entry(SPI_NAND_PROCNAME, NULL);
+		remove_proc_entry(SPI_NAND_TEST, NULL);
 	}	
 }
 
Index: linux-2.6.36/drivers/mtd/chips/spi_nand_flash.h
===================================================================
--- linux-2.6.36.orig/drivers/mtd/chips/spi_nand_flash.h	2017-04-22 16:45:21.000000000 +0800
+++ linux-2.6.36/drivers/mtd/chips/spi_nand_flash.h	2017-04-24 17:21:28.215443190 +0800
@@ -110,7 +110,9 @@
 /* Bitwise */
 #define SPI_NAND_FLASH_FEATURE_NONE			( 0x00 )
 #define SPI_NAND_FLASH_PLANE_SELECT_HAVE	( 0x01 )
-#define SPI_NAND_FLASH_DIE_SELECT_HAVE		( 0x01 << 1 )
+#define SPI_NAND_FLASH_DIE_SELECT_1_HAVE	( 0x01 << 1 )
+#define SPI_NAND_FLASH_DIE_SELECT_2_HAVE	( 0x01 << 2 )
+
 
 struct spi_nand_flash_oobfree{
 	unsigned long	offset;
@@ -133,6 +135,7 @@
 	u32									oob_size;		/* Spare Area (OOB) Size */
 	SPI_NAND_FLASH_READ_DUMMY_BYTE_T	dummy_mode;
 	u32									read_mode;
+	u32									write_mode;
 	struct spi_nand_flash_ooblayout		*oob_free_layout;
 	u32									feature;
 #if 0
@@ -418,6 +421,9 @@
  */
 void SPI_NAND_Flash_Clear_Read_Cache_Data( void );
 
+void SPI_NAND_Flash_Set_DmaMode( u32 input );
+void SPI_NAND_Flash_Get_DmaMode( u32 *val );
+
 #endif /* ifndef __SPI_NAND_FLASH_H__ */
 /* End of [spi_nand_flash.h] package */
 
Index: linux-2.6.36/drivers/mtd/chips/spi_nfi.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.36/drivers/mtd/chips/spi_nfi.c	2017-04-24 17:21:28.219443190 +0800
@@ -0,0 +1,818 @@
+/***************************************************************************************
+ *      Copyright(c) 2016 ECONET Incorporation All rights reserved.
+ *
+ *      This is unpublished proprietary source code of ECONET Incorporation
+ *
+ *      The copyright notice above does not evidence any actual or intended
+ *      publication of such source code.
+ ***************************************************************************************
+ */
+
+/*======================================================================================
+ * MODULE NAME: spi
+ * FILE NAME: spi_nfi.c
+ * DATE: 2016/03/18
+ * VERSION: 1.00
+ * PURPOSE: To Provide SPI NFI(DMA) Access Internace.
+ * NOTES:
+ *
+ * AUTHOR : Chuck Kuo         REVIEWED by
+ *
+ * FUNCTIONS
+ *
+ * DEPENDENCIES
+ *
+ * * $History: $
+ * MODIFICTION HISTORY:
+ * Version 1.00 - Date 2016/03/18 By Chuck Kuo
+ * ** This is the first versoin for creating to support the functions of
+ *    current module.
+ *
+ *======================================================================================
+ */
+
+
+/* INCLUDE FILE DECLARATIONS --------------------------------------------------------- */
+#include "spi_nfi.h"
+#include <asm/io.h>
+#include <asm/tc3162/tc3162.h>
+#include <stdarg.h>
+#include <asm/string.h>
+#include <linux/delay.h>
+
+/* NAMING CONSTANT DECLARATIONS ------------------------------------------------------ */
+
+
+/*******************************************************************************
+ * NFI Register Definition
+ *******************************************************************************/
+#define _SPI_NFI_REGS_BASE			0xBFA11000
+#define _SPI_NFI_REGS_CNFG			(_SPI_NFI_REGS_BASE + 0x0000)
+#define _SPI_NFI_REGS_PAGEFMT		(_SPI_NFI_REGS_BASE + 0x0004)
+#define _SPI_NFI_REGS_CON			(_SPI_NFI_REGS_BASE + 0x0008)
+#define _SPI_NFI_REGS_INTR_EN		(_SPI_NFI_REGS_BASE + 0x0010)
+#define _SPI_NFI_REGS_INTR			(_SPI_NFI_REGS_BASE + 0x0014)
+#define _SPI_NFI_REGS_CMD			(_SPI_NFI_REGS_BASE + 0x0020)
+#define _SPI_NFI_REGS_STA			(_SPI_NFI_REGS_BASE + 0x0060)
+#define _SPI_NFI_REGS_FIFOSTA		(_SPI_NFI_REGS_BASE + 0x0064)
+#define _SPI_NFI_REGS_STRADDR		(_SPI_NFI_REGS_BASE + 0x0080)
+#define _SPI_NFI_REGS_FDM0L			(_SPI_NFI_REGS_BASE + 0x00A0)
+#define _SPI_NFI_REGS_FDM0M			(_SPI_NFI_REGS_BASE + 0x00A4)
+#define _SPI_NFI_REGS_FDM7L			(_SPI_NFI_REGS_BASE + 0x00D8)
+#define _SPI_NFI_REGS_FDM7M			(_SPI_NFI_REGS_BASE + 0x00DC)
+#define _SPI_NFI_REGS_FIFODATA0		(_SPI_NFI_REGS_BASE + 0x0190)
+#define _SPI_NFI_REGS_FIFODATA1		(_SPI_NFI_REGS_BASE + 0x0194)
+#define _SPI_NFI_REGS_FIFODATA2		(_SPI_NFI_REGS_BASE + 0x0198)
+#define _SPI_NFI_REGS_FIFODATA3		(_SPI_NFI_REGS_BASE + 0x019C)
+#define _SPI_NFI_REGS_MASTERSTA		(_SPI_NFI_REGS_BASE + 0x0224)
+#define _SPI_NFI_REGS_SECCUS_SIZE	(_SPI_NFI_REGS_BASE + 0x022C)
+#define _SPI_NFI_REGS_RD_CTL2		(_SPI_NFI_REGS_BASE + 0x0510)
+#define _SPI_NFI_REGS_RD_CTL3		(_SPI_NFI_REGS_BASE + 0x0514)
+#define _SPI_NFI_REGS_PG_CTL1		(_SPI_NFI_REGS_BASE + 0x0524)
+#define _SPI_NFI_REGS_PG_CTL2		(_SPI_NFI_REGS_BASE + 0x0528)
+#define _SPI_NFI_REGS_NOR_PROG_ADDR	(_SPI_NFI_REGS_BASE + 0x052C)
+#define _SPI_NFI_REGS_NOR_RD_ADDR	(_SPI_NFI_REGS_BASE + 0x0534)
+#define _SPI_NFI_REGS_SNF_MISC_CTL	(_SPI_NFI_REGS_BASE + 0x0538)
+#define _SPI_NFI_REGS_SNF_MISC_CTL2	(_SPI_NFI_REGS_BASE + 0x053C)
+#define _SPI_NFI_REGS_SNF_STA_CTL1	(_SPI_NFI_REGS_BASE + 0x0550)
+#define _SPI_NFI_REGS_SNF_STA_CTL2	(_SPI_NFI_REGS_BASE + 0x0554)
+
+
+/*******************************************************************************
+ * NFI Register Field Definition
+ *******************************************************************************/
+
+/* NFI_CNFG */
+#define _SPI_NFI_REGS_CNFG_AHB				(0x0001)
+#define _SPI_NFI_REGS_CNFG_READ_EN			(0x0002)
+#define _SPI_NFI_REGS_CNFG_DMA_BURST_EN		(0x0004)
+#define _SPI_NFI_REGS_CNFG_HW_ECC_EN		(0x0100)
+#define _SPI_NFI_REGS_CNFG_AUTO_FMT_EN		(0x0200)
+
+#define _SPI_NFI_REGS_CONF_OP_PRGM			(3)
+#define _SPI_NFI_REGS_CONF_OP_READ			(6)
+#define _SPI_NFI_REGS_CONF_OP_MASK			(0x7000)
+#define _SPI_NFI_REGS_CONF_OP_SHIFT			(12)
+
+#define _SPI_NFI_REGS_CNFG_DMA_RD_SWAP_MASK		(0x0004)
+#define _SPI_NFI_REGS_CNFG_DMA_WR_SWAP_MASK		(0x0008)
+#define _SPI_NFI_REGS_CNFG_DMA_RD_SWAP_SHIFT	(0x0003)
+#define _SPI_NFI_REGS_CNFG_DMA_WR_SWAP_SHIFT	(0x0004)
+
+/* NFI_PAGEFMT */
+#define _SPI_NFI_REGS_PAGEFMT_PAGE_512		(0x0000)
+#define _SPI_NFI_REGS_PAGEFMT_PAGE_2K		(0x0001)
+#define _SPI_NFI_REGS_PAGEFMT_PAGE_4K		(0x0002)
+#define _SPI_NFI_REGS_PAGEFMT_PAGE_MASK		(0x0003)
+#define _SPI_NFI_REGS_PAGEFMT_PAGE_SHIFT	(0x0000)
+
+#define _SPI_NFI_REGS_PAGEFMT_SPARE_16			(0x0000)
+#define _SPI_NFI_REGS_PAGEFMT_SPARE_26			(0x0001)
+#define _SPI_NFI_REGS_PAGEFMT_SPARE_27			(0x0002)
+#define _SPI_NFI_REGS_PAGEFMT_SPARE_28			(0x0003)
+#define _SPI_NFI_REGS_PAGEFMT_SPARE_MASK		(0x0030)
+#define _SPI_NFI_REGS_PAGEFMT_SPARE_SHIFT		(4)
+
+#define _SPI_NFI_REGS_PAGEFMT_FDM_MASK			(0x0F00)
+#define _SPI_NFI_REGS_PAGEFMT_FDM_SHIFT			(8)
+#define _SPI_NFI_REGS_PAGEFMT_FDM_ECC_MASK  	(0xF000)
+#define _SPI_NFI_REGS_PAGEFMT_FDM_ECC_SHIFT 	(12)
+
+#define _SPI_NFI_REGS_PPAGEFMT_SPARE_16     	(0x0000)
+#define _SPI_NFI_REGS_PPAGEFMT_SPARE_26     	(0x0001)
+#define _SPI_NFI_REGS_PPAGEFMT_SPARE_27     	(0x0002)
+#define _SPI_NFI_REGS_PPAGEFMT_SPARE_28     	(0x0003)
+#define _SPI_NFI_REGS_PPAGEFMT_SPARE_MASK   	(0x0030)
+#define _SPI_NFI_REGS_PPAGEFMT_SPARE_SHIFT  	(4)
+
+/* NFI_CON */
+#define _SPI_NFI_REGS_CON_SEC_MASK				(0xF000)
+#define _SPI_NFI_REGS_CON_WR_TRIG				(0x0200)
+#define _SPI_NFI_REGS_CON_RD_TRIG				(0x0100)
+#define _SPI_NFI_REGS_CON_SEC_SHIFT				(12)
+#define _SPI_NFI_REGS_CON_RESET_VALUE			(0x3)
+
+/* NFI_INTR_EN */
+#define _SPI_NFI_REGS_INTR_EN_AHB_DONE_EN		(0x0040)
+
+/* NFI_REGS_INTR */
+#define _SPI_NFI_REGS_INTR_AHB_DONE_CHECK		(0x0040)
+
+/* NFI_SECCUS_SIZE */
+#define _SPI_NFI_REGS_SECCUS_SIZE_EN			(0x00010000)
+#define _SPI_NFI_REGS_SECCUS_SIZE_MASK			(0x00001FFF)
+#define _SPI_NFI_REGS_SECCUS_SIZE_SHIFT			(0)
+
+/* NFI_SNF_MISC_CTL */
+#define _SPI_NFI_REGS_SNF_MISC_CTL_DATA_RW_MODE_SHIFT	(16)
+
+/* NFI_SNF_MISC_CTL2 */
+#define _SPI_NFI_REGS_SNF_MISC_CTL2_WR_MASK		(0x1FFF0000)
+#define _SPI_NFI_REGS_SNF_MISC_CTL2_WR_SHIFT	(16)
+#define _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK		(0x00001FFF)
+#define _SPI_NFI_REGS_SNF_MISC_CTL2_RD_SHIFT	(0)
+
+/* NFI_REGS_CMD */
+#define _SPI_NFI_REGS_CMD_READ_VALUE			(0x00)
+#define _SPI_NFI_REGS_CMD_WRITE_VALUE			(0x80)
+
+
+/* NFI_REGS_PG_CTL1 */
+#define _SPI_NFI_REGS_PG_CTL1_SHIFT				(8)
+
+
+/* SNF_STA_CTL1 */
+#define _SPI_NFI_REGS_LOAD_TO_CACHE_DONE		(0x04000000)
+#define _SPI_NFI_REGS_READ_FROM_CACHE_DONE		(0x02000000)
+
+
+
+/* MACRO DECLARATIONS ---------------------------------------------------------------- */
+
+#define READ_REGISTER_UINT32(reg) \
+    (*(volatile unsigned int  * const)(reg))
+
+#define WRITE_REGISTER_UINT32(reg, val) \
+    (*(volatile unsigned int  * const)(reg)) = (val)
+
+#define INREG32(x)          READ_REGISTER_UINT32((unsigned int *)((void*)(x)))
+#define OUTREG32(x, y)      WRITE_REGISTER_UINT32((unsigned int *)((void*)(x)), (unsigned int )(y))
+#define SETREG32(x, y)      OUTREG32(x, INREG32(x)|(y))
+#define CLRREG32(x, y)      OUTREG32(x, INREG32(x)&~(y))
+#define MASKREG32(x, y, z)  OUTREG32(x, (INREG32(x)&~(y))|(z))
+
+#define _SPI_NFI_REG8_READ(addr)						INREG32(addr)
+#define _SPI_NFI_REG8_WRITE(addr, data)					OUTREG32(addr, data)
+#define _SPI_NFI_REG8_SETBITS(addr, data)				SETREG32(addr, data)
+#define _SPI_NFI_REG8_CLRBITS(addr, data)				CLRREG32(addr, data)
+#define _SPI_NFI_REG8_SETMASKBITS(addr, mask, data)	MASKREG32(addr, mask, data)
+
+#define _SPI_NFI_REG16_READ(addr)						INREG32(addr)
+#define _SPI_NFI_REG16_WRITE(addr, data)				OUTREG32(addr, data)
+#define _SPI_NFI_REG16_SETBITS(addr, data)				SETREG32(addr, data)
+#define _SPI_NFI_REG16_CLRBITS(addr, data)				CLRREG32(addr, data)
+#define _SPI_NFI_REG16_SETMASKBITS(addr, mask, data)	MASKREG32(addr, mask, data)
+
+#define _SPI_NFI_REG32_READ(addr)						INREG32(addr)
+#define _SPI_NFI_REG32_WRITE(addr, data)				OUTREG32(addr, data)
+#define _SPI_NFI_REG32_SETBITS(addr, data)				SETREG32(addr, data)
+#define _SPI_NFI_REG32_CLRBITS(addr, data)				CLRREG32(addr, data)
+#define _SPI_NFI_REG32_SETMASKBITS(addr, mask, data)	MASKREG32(addr, mask, data)
+
+#define _SPI_NFI_GET_CONF_PTR							&(_spi_nfi_conf_info_t)
+#define _SPI_NFI_GET_FDM_PTR							&(_spi_nfi_fdm_value)
+#define _SPI_NFI_SET_FDM_PTR							&(_spi_nfi_fdm_value)
+#define _SPI_NFI_DATA_SIZE_WITH_ECC						(512)
+#define _SPI_NFI_CHECK_DONE_MAX_TIMES					(1000000)
+
+#define _SPI_NFI_PRINTF									printk
+#define _SPI_NFI_DEBUG_PRINTF							spi_nfi_debug_printf
+
+#define _SPI_NFI_MEMCPY									memcpy
+#define _SPI_NFI_MEMSET									memset
+#define _SPI_NFI_MAX_FDM_NUMBER							(64)
+#define _SPI_NFI_MAX_FDM_PER_SEC						(8)
+
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+
+/* STATIC VARIABLE DECLARATIONS ------------------------------------------------------ */
+SPI_NFI_CONF_T	_spi_nfi_conf_info_t;
+u8				_spi_nfi_fdm_value[_SPI_NFI_MAX_FDM_NUMBER];
+u8				_SPI_NFI_DEBUG_FLAG = 0;	/* For control printf debug message or not */
+
+/* LOCAL SUBPROGRAM BODIES------------------------------------------------------------ */
+static void spi_nfi_debug_printf( char *fmt, ... )
+{
+	if( _SPI_NFI_DEBUG_FLAG == 1 )
+	{
+		unsigned char 		str_buf[100];
+		va_list 			argptr;
+		int 				cnt;
+
+		va_start(argptr, fmt);
+		cnt = vsprintf(str_buf, fmt, argptr);
+		va_end(argptr);
+
+		printk("%s", str_buf);
+	}
+}
+
+SPI_NFI_RTN_T spi_nfi_get_fdm_from_register( void )
+{
+	u32				idx, i, j, reg_addr, val;
+	u8				*fdm_value;
+	SPI_NFI_CONF_T	*spi_nfi_conf_info_t;
+	u8				spi_nfi_mapping_fdm_value[_SPI_NFI_MAX_FDM_NUMBER];
+
+	fdm_value = _SPI_NFI_GET_FDM_PTR;
+	spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+
+    _SPI_NFI_MEMSET(spi_nfi_mapping_fdm_value, 0xff, _SPI_NFI_MAX_FDM_NUMBER);
+	_SPI_NFI_MEMSET(fdm_value, 0xff, _SPI_NFI_MAX_FDM_NUMBER);
+
+	idx = 0;
+	for( reg_addr = _SPI_NFI_REGS_FDM0L ; reg_addr <= _SPI_NFI_REGS_FDM7M ; reg_addr+=4 )
+	{
+		val = _SPI_NFI_REG32_READ(reg_addr);
+		spi_nfi_mapping_fdm_value[idx++] = ( val & 0xFF) ;
+		spi_nfi_mapping_fdm_value[idx++] = ((val >> 8) & 0xFF) ;
+		spi_nfi_mapping_fdm_value[idx++] = ((val >> 16) & 0xFF) ;
+		spi_nfi_mapping_fdm_value[idx++] = ((val >> 24) & 0xFF) ;
+	}
+
+	j=0;
+	for(idx=0 ; idx< (spi_nfi_conf_info_t->sec_num) ; idx++)
+	{
+		for(i =0; i< (spi_nfi_conf_info_t->fdm_num); i++)
+		{
+			fdm_value[j] = spi_nfi_mapping_fdm_value[(idx*_SPI_NFI_MAX_FDM_PER_SEC)+i];
+			j++;
+		}
+	}
+
+	return (SPI_NFI_RTN_NO_ERROR);
+}
+
+
+SPI_NFI_RTN_T spi_nfi_set_fdm_into_register( void )
+{
+	u32				idx, i,j, reg_addr, val;
+	u8				*fdm_value;
+	SPI_NFI_CONF_T	*spi_nfi_conf_info_t;
+	u8				spi_nfi_mapping_fdm_value[_SPI_NFI_MAX_FDM_NUMBER];
+
+	fdm_value 			= _SPI_NFI_GET_FDM_PTR;
+	spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+
+    _SPI_NFI_MEMSET(spi_nfi_mapping_fdm_value, 0xff, _SPI_NFI_MAX_FDM_NUMBER);
+
+	j=0;
+	for(idx=0 ; idx< (spi_nfi_conf_info_t->sec_num) ; idx++)
+	{
+		for(i =0; i< (spi_nfi_conf_info_t->fdm_num); i++)
+		{
+			spi_nfi_mapping_fdm_value[(idx*_SPI_NFI_MAX_FDM_PER_SEC)+i] = fdm_value[j];
+			j++;
+		}
+	}
+
+
+	idx = 0;
+	for( reg_addr = _SPI_NFI_REGS_FDM0L ; reg_addr <= _SPI_NFI_REGS_FDM7M ; reg_addr+=4 )
+	{
+		val = 0;
+
+		val |= (spi_nfi_mapping_fdm_value[idx++] & (0xFF));
+		val |= ((spi_nfi_mapping_fdm_value[idx++] & (0xFF)) << 8);
+		val |= ((spi_nfi_mapping_fdm_value[idx++] & (0xFF)) << 16);
+		val |= ((spi_nfi_mapping_fdm_value[idx++] & (0xFF)) << 24);
+
+		 _SPI_NFI_REG32_WRITE(reg_addr, val);
+
+		_SPI_NFI_DEBUG_PRINTF("spi_nfi_set_fdm_into_register : reg(0x%x)=0x%x\n", reg_addr, _SPI_NFI_REG32_READ(reg_addr));
+	}
+
+	return (SPI_NFI_RTN_NO_ERROR);
+}
+
+
+
+/* EXPORTED SUBPROGRAM BODIES -------------------------------------------------------- */
+SPI_NFI_RTN_T SPI_NFI_Regs_Dump( void )
+{
+	u32		idx;
+
+	for(idx = _SPI_NFI_REGS_BASE ; idx <= _SPI_NFI_REGS_SNF_STA_CTL2 ; idx +=4)
+	{
+		_SPI_NFI_PRINTF("reg(0x%x) = 0x%x\n", idx, _SPI_NFI_REG32_READ(idx) );
+	}
+
+	return (SPI_NFI_RTN_NO_ERROR);
+}
+
+SPI_NFI_RTN_T SPI_NFI_Read_SPI_NAND_FDM(u8 *ptr_rtn_oob, u32 oob_len)
+{
+	u8		*fdm_value;
+	u32		idx;
+
+	spi_nfi_get_fdm_from_register();
+	fdm_value = _SPI_NFI_GET_FDM_PTR;
+
+	_SPI_NFI_MEMCPY(ptr_rtn_oob, fdm_value, oob_len);
+
+	return (SPI_NFI_RTN_NO_ERROR);
+
+}
+
+SPI_NFI_RTN_T SPI_NFI_Write_SPI_NAND_FDM(u8 *ptr_oob, u32 oob_len)
+{
+	u8		*fdm_value;
+	u32		idx;
+
+	fdm_value = _SPI_NFI_GET_FDM_PTR;
+
+	if( oob_len	> _SPI_NFI_MAX_FDM_NUMBER )
+	{
+		_SPI_NFI_MEMCPY(fdm_value, ptr_oob, _SPI_NFI_MAX_FDM_NUMBER);
+	}
+	else
+	{
+		_SPI_NFI_MEMCPY(fdm_value, ptr_oob, oob_len);
+	}
+
+	spi_nfi_set_fdm_into_register();
+
+	return (SPI_NFI_RTN_NO_ERROR);
+
+}
+
+SPI_NFI_RTN_T SPI_NFI_Read_SPI_NAND_Page(SPI_NFI_MISC_SPEDD_CONTROL_T speed_mode, u32 read_cmd, u16 read_addr, u32 *prt_rtn_data)
+{
+	u32				check_cnt;
+	SPI_NFI_CONF_T	*spi_nfi_conf_info_t;
+	SPI_NFI_RTN_T	rtn_status = SPI_NFI_RTN_NO_ERROR;
+
+
+	spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+
+	/* Set DMA destination address */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_STRADDR, prt_rtn_data);
+
+	/* Set Read length */
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Disable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK,	\
+				((_SPI_NFI_DATA_SIZE_WITH_ECC + (spi_nfi_conf_info_t->spare_size_t)) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_SNF_MISC_CTL2_RD_SHIFT );
+	}
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Enable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK,	\
+				((spi_nfi_conf_info_t->sec_size) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_SNF_MISC_CTL2_RD_SHIFT );
+	}
+
+	/* Set Read Command */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_RD_CTL2, (read_cmd & 0xFF));
+
+	/* Set Read mode */
+	_SPI_NFI_REG32_WRITE(_SPI_NFI_REGS_SNF_MISC_CTL, (speed_mode << _SPI_NFI_REGS_SNF_MISC_CTL_DATA_RW_MODE_SHIFT));
+
+	/* Set Read Address (Note : Controller will use following register, depend on the Hardware TRAP of SPI NAND/SPI NOR  )*/
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_RD_CTL3, read_addr);		/* Set Address into SPI NAND address register*/
+
+	/* Set NFI Read */
+	_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CONF_OP_MASK, \
+								(_SPI_NFI_REGS_CONF_OP_READ << _SPI_NFI_REGS_CONF_OP_SHIFT ));
+	_SPI_NFI_REG16_SETBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_READ_EN);
+	_SPI_NFI_REG16_SETBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_AHB);
+
+
+	_SPI_NFI_REG16_WRITE( _SPI_NFI_REGS_CMD, _SPI_NFI_REGS_CMD_READ_VALUE);
+
+
+	/* Trigger DMA read active*/
+	SPI_NFI_TRIGGER(SPI_NFI_CON_DMA_TRIGGER_READ);
+
+	/* Check read from cache  done or not */
+	for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_DONE_MAX_TIMES ; check_cnt ++)
+	{
+		if( (_SPI_NFI_REG16_READ(_SPI_NFI_REGS_SNF_STA_CTL1)& (_SPI_NFI_REGS_READ_FROM_CACHE_DONE)) != 0 )
+		{
+			/* Clear this bit is neccessary for NFI state machine */
+			_SPI_NFI_REG32_SETBITS(_SPI_NFI_REGS_SNF_STA_CTL1, _SPI_NFI_REGS_READ_FROM_CACHE_DONE);
+			break;
+		}
+	}
+	if(check_cnt == _SPI_NFI_CHECK_DONE_MAX_TIMES)
+	{
+		_SPI_NFI_PRINTF("[Error] Read DMA : Check READ FROM CACHE Done Timeout ! \n");
+		rtn_status = SPI_NFI_RTN_READ_FROM_CACHE_DONE_TIMEOUT;
+	}
+
+
+	/* Check DMA done or not */
+	for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_DONE_MAX_TIMES ; check_cnt ++)
+	{
+		if( (_SPI_NFI_REG16_READ(_SPI_NFI_REGS_INTR)& (_SPI_NFI_REGS_INTR_AHB_DONE_CHECK)) != 0 )
+		{
+			break;
+		}
+	}
+	if(check_cnt == _SPI_NFI_CHECK_DONE_MAX_TIMES)
+	{
+		_SPI_NFI_PRINTF("[Error] Read DMA : Check AHB Done Timeout ! \n");
+		rtn_status = SPI_NFI_RTN_CHECK_AHB_DONE_TIMEOUT;
+	}
+
+	/* Does DMA read need delay for data ready from controller to DRAM */
+	udelay(1);
+
+	return (rtn_status);
+}
+
+SPI_NFI_RTN_T SPI_NFI_Write_SPI_NAND_page(SPI_NFI_MISC_SPEDD_CONTROL_T speed_mode, u32 write_cmd, u16 write_addr, u32 *prt_data)
+{
+
+	volatile u32				check_cnt;
+	SPI_NFI_CONF_T	*spi_nfi_conf_info_t;
+	SPI_NFI_RTN_T	rtn_status = SPI_NFI_RTN_NO_ERROR;
+
+	_SPI_NFI_DEBUG_PRINTF("SPI_NFI_Write_SPI_NAND_page : enter, speed_mode=%d, write_cmd=0x%x, write_addr=0x%x, prt_data=0x%x\n", speed_mode, write_cmd, write_addr, prt_data);
+
+
+	spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+
+	/* Set DMA destination address */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_STRADDR, prt_data);
+
+	_SPI_NFI_DEBUG_PRINTF("SPI_NFI_Write_SPI_NAND_page: _SPI_NFI_REGS_STRADDR=0x%x\n", _SPI_NFI_REG32_READ(_SPI_NFI_REGS_STRADDR));
+	_SPI_NFI_DEBUG_PRINTF("SPI_NFI_Write_SPI_NAND_page\n");
+
+	/* Set Write length */
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Disable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_WR_MASK,	\
+				((_SPI_NFI_DATA_SIZE_WITH_ECC + (spi_nfi_conf_info_t->spare_size_t)) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_SNF_MISC_CTL2_WR_SHIFT );
+	}
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Enable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_WR_MASK,	\
+				((spi_nfi_conf_info_t->sec_size) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_SNF_MISC_CTL2_WR_SHIFT );
+	}
+
+	/* Set Write Command */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_PG_CTL1, ((write_cmd & 0xFF) << _SPI_NFI_REGS_PG_CTL1_SHIFT));
+
+	/* Set Write mode */
+	_SPI_NFI_REG32_WRITE(_SPI_NFI_REGS_SNF_MISC_CTL, (speed_mode << _SPI_NFI_REGS_SNF_MISC_CTL_DATA_RW_MODE_SHIFT));
+
+	/* Set Write Address (Note : Controller will use following register, depend on the Hardware TRAP of SPI NAND/SPI NOR  )*/
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_PG_CTL2, write_addr);		/* Set Address into SPI NAND address register*/
+
+	/* Set NFI Write */
+	_SPI_NFI_REG16_CLRBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_READ_EN);
+	_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CONF_OP_MASK, \
+								(_SPI_NFI_REGS_CONF_OP_PRGM << _SPI_NFI_REGS_CONF_OP_SHIFT ));
+
+	_SPI_NFI_REG16_SETBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_AHB);
+	_SPI_NFI_REG16_WRITE( _SPI_NFI_REGS_CMD, _SPI_NFI_REGS_CMD_WRITE_VALUE);
+
+
+	/* Trigger DMA write active*/
+	SPI_NFI_TRIGGER(SPI_NFI_CON_DMA_TRIGGER_WRITE);
+
+	/* Does DMA read need delay for data ready from controller to DRAM */
+	udelay(1);
+
+	/* Check DMA done or not */
+	for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_DONE_MAX_TIMES ; check_cnt ++)
+	{
+		if( (_SPI_NFI_REG16_READ(_SPI_NFI_REGS_INTR)& (_SPI_NFI_REGS_INTR_AHB_DONE_CHECK)) != 0 )
+		{
+			break;
+		}
+	}
+	if(check_cnt == _SPI_NFI_CHECK_DONE_MAX_TIMES)
+	{
+		_SPI_NFI_PRINTF("[Error] Write DMA : Check AHB Done Timeout ! \n");
+		rtn_status = SPI_NFI_RTN_CHECK_AHB_DONE_TIMEOUT;
+	}
+
+
+	/* Check load to cache  done or not */
+	for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_DONE_MAX_TIMES ; check_cnt ++)
+	{
+		if( (_SPI_NFI_REG16_READ(_SPI_NFI_REGS_SNF_STA_CTL1)& (_SPI_NFI_REGS_LOAD_TO_CACHE_DONE)) != 0 )
+		{
+			/* Clear this bit is neccessary for NFI state machine */
+			_SPI_NFI_REG32_SETBITS(_SPI_NFI_REGS_SNF_STA_CTL1, _SPI_NFI_REGS_LOAD_TO_CACHE_DONE);
+			break;
+		}
+	}
+	if(check_cnt == _SPI_NFI_CHECK_DONE_MAX_TIMES)
+	{
+		_SPI_NFI_PRINTF("[Error] Write DMA : Check LOAD TO CACHE Done Timeout ! \n");
+		rtn_status = SPI_NFI_RTN_LOAD_TO_CACHE_DONE_TIMEOUT;
+	}
+
+
+	_SPI_NFI_DEBUG_PRINTF("SPI_NFI_Write_SPI_NAND_page : exit \n");
+
+	return (rtn_status);
+
+}
+
+SPI_NFI_RTN_T SPI_NFI_Read_SPI_NOR(u8 opcode, u16 read_addr, u32 *prt_rtn_data)
+{
+	u32				check_cnt;
+	SPI_NFI_CONF_T	*spi_nfi_conf_info_t;
+	SPI_NFI_RTN_T	rtn_status = SPI_NFI_RTN_NO_ERROR;
+
+
+	spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+
+	/* Set Read length */
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Disable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK,	\
+				((_SPI_NFI_DATA_SIZE_WITH_ECC + (spi_nfi_conf_info_t->spare_size_t)) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_CON_SEC_SHIFT );
+	}
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Enable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK,	\
+				((spi_nfi_conf_info_t->sec_size) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_CON_SEC_SHIFT );
+	}
+
+	/* Set Read Command */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_RD_CTL2, (u32) opcode);
+
+	/* Set Read Address (Note : Controller will use following register, depend on the Hardware TRAP of SPI NAND/SPI NOR  )*/
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_NOR_RD_ADDR, read_addr);	/* Set Address into SPI NOR address register*/
+
+	/* Reset NFI statemachile and flush fifo*/
+	_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RESET_VALUE);
+
+	/* Set NFI Read */
+	_SPI_NFI_REG16_WRITE( _SPI_NFI_REGS_CMD, _SPI_NFI_REGS_CMD_READ_VALUE);
+
+	/* Set DMA destination address */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_STRADDR, prt_rtn_data);
+
+	/* Trigger DMA read active*/
+	_SPI_NFI_REG16_CLRBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RD_TRIG);
+	 /* [Note : Is here need to have little time delay or not ? */
+	_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RD_TRIG);
+
+	/* Check DMA done or not */
+	for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_DONE_MAX_TIMES ; check_cnt ++)
+	{
+		if( (_SPI_NFI_REG16_READ(_SPI_NFI_REGS_INTR)& (_SPI_NFI_REGS_INTR_AHB_DONE_CHECK)) != 0 )
+		{
+			break;
+		}
+	}
+	if(check_cnt == _SPI_NFI_CHECK_DONE_MAX_TIMES)
+	{
+		_SPI_NFI_PRINTF("[Error] Read DMA : Check AHB Done Timeout ! \n");
+		rtn_status = SPI_NFI_RTN_CHECK_AHB_DONE_TIMEOUT;
+	}
+
+	return (rtn_status);
+}
+
+SPI_NFI_RTN_T SPI_NFI_Write_SPI_NOR(u8 opcode, u16 write_addr, u32 *prt_data)
+{
+
+	u32				check_cnt;
+	SPI_NFI_CONF_T	*spi_nfi_conf_info_t;
+	SPI_NFI_RTN_T	rtn_status = SPI_NFI_RTN_NO_ERROR;
+
+	/* Set Write length */
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Disable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK,	\
+				((_SPI_NFI_DATA_SIZE_WITH_ECC + (spi_nfi_conf_info_t->spare_size_t)) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_CON_SEC_SHIFT );
+	}
+	if( (spi_nfi_conf_info_t-> cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Enable )
+	{
+		_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SNF_MISC_CTL2, _SPI_NFI_REGS_SNF_MISC_CTL2_RD_MASK,	\
+				((spi_nfi_conf_info_t->sec_size) * (spi_nfi_conf_info_t->sec_num))<< _SPI_NFI_REGS_CON_SEC_SHIFT );
+	}
+
+	/* Set Write Command */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_PG_CTL1, ((u32) opcode) << _SPI_NFI_REGS_PG_CTL1_SHIFT);
+
+	/* Set Write Address (Note : Controller will use following register, depend on the Hardware TRAP of SPI NAND/SPI NOR  )*/
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_NOR_PROG_ADDR, write_addr);	/* Set Address into SPI NOR address register*/
+
+	/* Reset NFI statemachile and flush fifo*/
+	_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RESET_VALUE);
+
+	/* Set NFI Write */
+	_SPI_NFI_REG16_WRITE( _SPI_NFI_REGS_CMD, _SPI_NFI_REGS_CMD_WRITE_VALUE);
+
+	/* Set DMA destination address */
+	_SPI_NFI_REG32_WRITE( _SPI_NFI_REGS_STRADDR, prt_data);
+
+	/* Trigger DMA read active*/
+	_SPI_NFI_REG16_CLRBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_WR_TRIG);
+	 /* [Note : Is here need to have little time delay or not ? */
+	_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_WR_TRIG);
+
+	/* Check DMA done or not */
+	for( check_cnt = 0 ; check_cnt < _SPI_NFI_CHECK_DONE_MAX_TIMES ; check_cnt ++)
+	{
+		if( (_SPI_NFI_REG16_READ(_SPI_NFI_REGS_INTR)& (_SPI_NFI_REGS_INTR_AHB_DONE_CHECK)) != 0 )
+		{
+			break;
+		}
+	}
+	if(check_cnt == _SPI_NFI_CHECK_DONE_MAX_TIMES)
+	{
+		_SPI_NFI_PRINTF("[Error] Write DMA : Check AHB Done Timeout ! \n");
+		rtn_status = SPI_NFI_RTN_CHECK_AHB_DONE_TIMEOUT;
+	}
+
+
+	return (rtn_status);
+
+}
+
+SPI_NFI_RTN_T SPI_NFI_Get_Configure( SPI_NFI_CONF_T *ptr_rtn_nfi_conf_t )
+{
+	SPI_NFI_CONF_T  *ptr_spi_nfi_conf_info_t;
+
+	ptr_spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+	_SPI_NFI_MEMCPY(ptr_rtn_nfi_conf_t, ptr_spi_nfi_conf_info_t, sizeof(SPI_NFI_CONF_T));
+
+	return (SPI_NFI_RTN_NO_ERROR);
+}
+
+
+SPI_NFI_RTN_T SPI_NFI_Set_Configure( SPI_NFI_CONF_T *ptr_nfi_conf_t )
+{
+	SPI_NFI_CONF_T  *ptr_spi_nfi_conf_info_t;
+
+	/* Store new setting */
+	ptr_spi_nfi_conf_info_t = _SPI_NFI_GET_CONF_PTR;
+	_SPI_NFI_MEMCPY(ptr_spi_nfi_conf_info_t, ptr_nfi_conf_t, sizeof(SPI_NFI_CONF_T));
+
+
+	_SPI_NFI_DEBUG_PRINTF("SPI_NFI_Set_Configure: hw_ecc_t= 0x%x\n", ptr_nfi_conf_t->hw_ecc_t );
+
+	/* Set Auto FDM */
+	if( (ptr_nfi_conf_t->auto_fdm_t) == SPI_NFI_CON_AUTO_FDM_Disable )
+	{
+		_SPI_NFI_REG16_CLRBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_AUTO_FMT_EN);
+	}
+	if( (ptr_nfi_conf_t->auto_fdm_t) == SPI_NFI_CON_AUTO_FDM_Enable )
+	{
+		_SPI_NFI_REG16_SETBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_AUTO_FMT_EN);
+	}
+
+	/* Set Hardware ECC */
+	if( (ptr_nfi_conf_t->hw_ecc_t) == SPI_NFI_CON_HW_ECC_Disable )
+	{
+		_SPI_NFI_REG16_CLRBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_HW_ECC_EN);
+	}
+	if( (ptr_nfi_conf_t->hw_ecc_t) == SPI_NFI_CON_HW_ECC_Enable )
+	{
+		_SPI_NFI_REG16_SETBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_HW_ECC_EN);
+	}
+
+	/* Set DMA BURST */
+	if( (ptr_nfi_conf_t->dma_burst_t) == SPI_NFI_CON_DMA_BURST_Disable )
+	{
+		_SPI_NFI_REG16_CLRBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_DMA_BURST_EN);
+	}
+	if( (ptr_nfi_conf_t->dma_burst_t) == SPI_NFI_CON_DMA_BURST_Enable )
+	{
+		_SPI_NFI_REG16_SETBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_DMA_BURST_EN);
+	}
+
+	/* Set FDM Number */
+	_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_FDM_MASK,	\
+								(ptr_nfi_conf_t->fdm_num)<< _SPI_NFI_REGS_PAGEFMT_FDM_SHIFT );
+
+	/* Set FDM ECC Number */
+	_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_FDM_ECC_MASK,	\
+								(ptr_nfi_conf_t->fdm_ecc_num)<< _SPI_NFI_REGS_PAGEFMT_FDM_ECC_SHIFT );
+
+	/* Set SPARE Size */
+	if( (ptr_nfi_conf_t->spare_size_t) == SPI_NFI_CONF_SPARE_SIZE_16BYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_SPARE_MASK,	\
+								_SPI_NFI_REGS_PAGEFMT_SPARE_16 << _SPI_NFI_REGS_PAGEFMT_SPARE_SHIFT );
+	}
+	if( (ptr_nfi_conf_t->spare_size_t) == SPI_NFI_CONF_SPARE_SIZE_26BYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_SPARE_MASK,	\
+								_SPI_NFI_REGS_PAGEFMT_SPARE_26 << _SPI_NFI_REGS_PAGEFMT_SPARE_SHIFT );
+	}
+	if( (ptr_nfi_conf_t->spare_size_t) == SPI_NFI_CONF_SPARE_SIZE_27BYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_SPARE_MASK,	\
+								_SPI_NFI_REGS_PAGEFMT_SPARE_27 << _SPI_NFI_REGS_PAGEFMT_SPARE_SHIFT );
+	}
+	if( (ptr_nfi_conf_t->spare_size_t) == SPI_NFI_CONF_SPARE_SIZE_28BYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_SPARE_MASK,	\
+								_SPI_NFI_REGS_PAGEFMT_SPARE_28 << _SPI_NFI_REGS_PAGEFMT_SPARE_SHIFT );
+	}
+
+	/* Set PAGE Size */
+	if( (ptr_nfi_conf_t->page_size_t) == SPI_NFI_CONF_PAGE_SIZE_512BYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_PAGE_MASK,	\
+								   _SPI_NFI_REGS_PAGEFMT_PAGE_512 << _SPI_NFI_REGS_PAGEFMT_PAGE_SHIFT );
+	}
+	if( (ptr_nfi_conf_t->page_size_t) == SPI_NFI_CONF_PAGE_SIZE_2KBYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_PAGE_MASK,	\
+								   _SPI_NFI_REGS_PAGEFMT_PAGE_2K << _SPI_NFI_REGS_PAGEFMT_PAGE_SHIFT );
+	}
+	if( (ptr_nfi_conf_t->page_size_t) == SPI_NFI_CONF_PAGE_SIZE_4KBYTE )
+	{
+		_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_PAGEFMT, _SPI_NFI_REGS_PAGEFMT_PAGE_MASK,	\
+								   _SPI_NFI_REGS_PAGEFMT_PAGE_4K << _SPI_NFI_REGS_PAGEFMT_PAGE_SHIFT );
+	}
+
+	/* Set sector number */
+	_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_SEC_MASK,	\
+								(ptr_nfi_conf_t->sec_num)<< _SPI_NFI_REGS_CON_SEC_SHIFT );
+
+	/* Enable Customer setting sector size or not */
+	if( (ptr_nfi_conf_t->cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Disable )
+	{
+		_SPI_NFI_REG32_CLRBITS(_SPI_NFI_REGS_SECCUS_SIZE, _SPI_NFI_REGS_SECCUS_SIZE_EN);
+	}
+	if( (ptr_nfi_conf_t->cus_sec_size_en_t) == SPI_NFI_CONF_CUS_SEC_SIZE_Enable )
+	{
+		_SPI_NFI_REG32_SETBITS(_SPI_NFI_REGS_SECCUS_SIZE, _SPI_NFI_REGS_SECCUS_SIZE_EN);
+	}
+
+	/* Set Customer sector size */
+	_SPI_NFI_REG32_SETMASKBITS(_SPI_NFI_REGS_SECCUS_SIZE, _SPI_NFI_REGS_SECCUS_SIZE_MASK,	\
+								(ptr_nfi_conf_t->sec_size)<< _SPI_NFI_REGS_SECCUS_SIZE_SHIFT );
+}
+
+void SPI_NFI_Reset( void )
+{
+	/* Reset NFI statemachile and flush fifo*/
+	_SPI_NFI_REG16_WRITE( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RESET_VALUE);
+}
+
+SPI_NFI_RTN_T SPI_NFI_Init( void )
+{
+	/* Enable AHB Done Interrupt Function */
+	_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_INTR_EN, _SPI_NFI_REGS_INTR_EN_AHB_DONE_EN);
+}
+
+void SPI_NFI_DEBUG_ENABLE( void )
+{
+	_SPI_NFI_DEBUG_FLAG = 1;
+}
+
+void SPI_NFI_DEBUG_DISABLE( void )
+{
+	_SPI_NFI_DEBUG_FLAG = 0;
+}
+
+/* Trigger DMA read active*/
+void SPI_NFI_TRIGGER(SPI_NFI_CONF_DMA_TRIGGER_T rw)
+{
+	if(rw == SPI_NFI_CON_DMA_TRIGGER_READ) {
+		_SPI_NFI_REG16_CLRBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RD_TRIG);
+		_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_RD_TRIG);
+	} else {
+		_SPI_NFI_REG16_CLRBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_WR_TRIG);
+		_SPI_NFI_REG16_SETBITS( _SPI_NFI_REGS_CON, _SPI_NFI_REGS_CON_WR_TRIG);
+	}
+}
+
+/* Set DMA(flash -> SRAM) byte swap*/
+void SPI_NFI_DMA_RD_BYTE_SWAP(SPI_NFI_CONF_DMA_RD_BYTE_SWAP_T enable)
+{
+	_SPI_NFI_REG16_SETMASKBITS(_SPI_NFI_REGS_CNFG, _SPI_NFI_REGS_CNFG_DMA_RD_SWAP_MASK, enable << _SPI_NFI_REGS_CNFG_DMA_RD_SWAP_SHIFT);
+}
+
Index: linux-2.6.36/drivers/mtd/chips/spi_nfi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.36/drivers/mtd/chips/spi_nfi.h	2017-04-24 17:21:28.219443190 +0800
@@ -0,0 +1,156 @@
+ /***************************************************************************************
+ *      Copyright(c) 2016 ECONET Incorporation All rights reserved.
+ *
+ *      This is unpublished proprietary source code of ECONET Incorporation
+ *
+ *      The copyright notice above does not evidence any actual or intended
+ *      publication of such source code.
+ ***************************************************************************************
+ */
+ 
+ /*======================================================================================
+ * MODULE NAME: spi
+ * FILE NAME: spi_nfi.h
+ * DATE: 2016/03/18
+ * VERSION: 1.00
+ * PURPOSE: To Provide SPI NFI(DMA) Access Internace. 
+ * NOTES:
+ *
+ * AUTHOR : Chuck Kuo         REVIEWED by
+ *
+ * FUNCTIONS
+ *
+ * DEPENDENCIES
+ *
+ * * $History: $
+ * MODIFICTION HISTORY:
+ * Version 1.00 - Date 2016/03/18 By Chuck Kuo
+ * ** This is the first versoin for creating to support the functions of
+ *    current module.
+ *
+ *======================================================================================
+ */
+
+#ifndef __SPI_NFI_H__
+    #define __SPI_NFI_H__
+
+ 
+/* INCLUDE FILE DECLARATIONS --------------------------------------------------------- */
+#include <asm/types.h>
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+typedef enum 
+{
+   SPI_NFI_CON_AUTO_FDM_Disable=0,
+   SPI_NFI_CON_AUTO_FDM_Enable,
+} SPI_NFI_CONF_AUTO_FDM_T;
+
+typedef enum 
+{
+   SPI_NFI_CON_HW_ECC_Disable=0,
+   SPI_NFI_CON_HW_ECC_Enable,
+} SPI_NFI_CONF_HW_ECC_T;
+
+typedef enum 
+{
+   SPI_NFI_CON_DMA_TRIGGER_READ=0,
+   SPI_NFI_CON_DMA_TRIGGER_WRITE,
+} SPI_NFI_CONF_DMA_TRIGGER_T;
+
+typedef enum 
+{
+   SPI_NFI_CON_DMA_BURST_Disable=0,
+   SPI_NFI_CON_DMA_BURST_Enable,
+} SPI_NFI_CONF_DMA_BURST_T;
+
+typedef enum
+{
+	SPI_NFI_CONF_SPARE_SIZE_16BYTE = 16,
+	SPI_NFI_CONF_SPARE_SIZE_26BYTE = 26,
+	SPI_NFI_CONF_SPARE_SIZE_27BYTE = 27,
+	SPI_NFI_CONF_SPARE_SIZE_28BYTE = 28,
+} SPI_NFI_CONF_SPARE_SIZE_T;
+
+typedef enum
+{
+	SPI_NFI_CONF_PAGE_SIZE_512BYTE = 512,
+	SPI_NFI_CONF_PAGE_SIZE_2KBYTE  = 2048,
+	SPI_NFI_CONF_PAGE_SIZE_4KBYTE  = 4096,
+} SPI_NFI_CONF_PAGE_SIZE_T;
+
+typedef enum
+{
+	SPI_NFI_CONF_CUS_SEC_SIZE_Disable=0,
+	SPI_NFI_CONF_CUS_SEC_SIZE_Enable,
+} SPI_NFI_CONF_CUS_SEC_SIZE_T;
+
+
+typedef enum
+{
+	SPI_NFI_MISC_CONTROL_X1		 = 0x000,
+	SPI_NFI_MISC_CONTROL_X2		 = 0x001,
+	SPI_NFI_MISC_CONTROL_X4		 = 0x010,
+	SPI_NFI_MISC_CONTROL_DUAL_IO = 0x101,
+	SPI_NFI_MISC_CONTROL_QUAD_IO = 0x110,
+	
+} SPI_NFI_MISC_SPEDD_CONTROL_T;
+
+typedef struct SPI_NFI_CONFIGURE
+{
+	SPI_NFI_CONF_AUTO_FDM_T			auto_fdm_t;			/* auto padding oob behind data, or not */
+	SPI_NFI_CONF_HW_ECC_T			hw_ecc_t;			/* enable hw ecc or not */
+	SPI_NFI_CONF_DMA_BURST_T		dma_burst_t;		/* dma burst */	
+	u8								fdm_num;			/* value range : 0 ~ 8 */
+	u8								fdm_ecc_num;		/* value range : 0 ~ 8 */
+														/* fdm byte under ecc protection */
+	SPI_NFI_CONF_SPARE_SIZE_T   	spare_size_t;		/* spare size of eache sector */
+	SPI_NFI_CONF_PAGE_SIZE_T		page_size_t;		/* page size (not incluing oob size) */
+	u8								sec_num;	   		/* number of sector */
+														/* value range : 1 ~ 8 */
+	SPI_NFI_CONF_CUS_SEC_SIZE_T	 	cus_sec_size_en_t;	/* To apply user define sector size or not */
+														/* Disable : sector size = 512 bytes, 
+															and ECC function will work */
+														/* Enable  : user define sector size, 
+												       		and ECC function will not work */
+	u32								sec_size;			/* Only work if cus_sec_size_en is enable */
+														/* value range : 1 ~ 8187 */
+	SPI_NFI_MISC_SPEDD_CONTROL_T	speed_t;
+	
+} SPI_NFI_CONF_T;
+
+
+
+typedef enum{
+	SPI_NFI_RTN_NO_ERROR =0,
+	SPI_NFI_RTN_CHECK_AHB_DONE_TIMEOUT,
+	SPI_NFI_RTN_LOAD_TO_CACHE_DONE_TIMEOUT,
+	SPI_NFI_RTN_READ_FROM_CACHE_DONE_TIMEOUT,
+
+	SPI_NFI_RTN_DEF_NO
+} SPI_NFI_RTN_T;
+						
+typedef enum{
+	SPI_NFI_CONF_DMA_RD_BYTE_SWAP_DISABLE =0,
+	SPI_NFI_CONF_DMA_RD_BYTE_SWAP_ENABLE
+} SPI_NFI_CONF_DMA_RD_BYTE_SWAP_T;	
+
+/* EXPORTED SUBPROGRAM SPECIFICATION ------------------------------------------------- */ 										
+					
+SPI_NFI_RTN_T SPI_NFI_Regs_Dump( void );
+SPI_NFI_RTN_T SPI_NFI_Read_SPI_NAND_FDM(u8 *ptr_rtn_oob, u32 oob_len);
+SPI_NFI_RTN_T SPI_NFI_Write_SPI_NAND_FDM(u8 *ptr_oob, u32 oob_len);
+SPI_NFI_RTN_T SPI_NFI_Read_SPI_NAND_Page(SPI_NFI_MISC_SPEDD_CONTROL_T speed_mode, u32 read_cmd, u16 read_addr, u32 *prt_rtn_data);
+SPI_NFI_RTN_T SPI_NFI_Write_SPI_NAND_page(SPI_NFI_MISC_SPEDD_CONTROL_T speed_mode, u32 write_cmd, u16 write_addr, u32 *prt_data);
+SPI_NFI_RTN_T SPI_NFI_Read_SPI_NOR(u8 opcode, u16 read_addr, u32 *prt_rtn_data);
+SPI_NFI_RTN_T SPI_NFI_Write_SPI_NOR(u8 opcode, u16 write_addr, u32 *prt_data);
+SPI_NFI_RTN_T SPI_NFI_Get_Configure( SPI_NFI_CONF_T *ptr_rtn_nfi_conf_t );
+SPI_NFI_RTN_T SPI_NFI_Set_Configure( SPI_NFI_CONF_T *ptr_nfi_conf_t );
+void SPI_NFI_Reset( void );
+SPI_NFI_RTN_T SPI_NFI_Init( void );
+void SPI_NFI_DEBUG_ENABLE( void );
+void SPI_NFI_DEBUG_DISABLE( void );
+/* Set DMA(flash -> SRAM) byte swap*/
+void SPI_NFI_DMA_RD_BYTE_SWAP(SPI_NFI_CONF_DMA_RD_BYTE_SWAP_T enable);
+
+#endif /* ifndef __SPI_NFI_H__ */
+/* End of [spi_nfi.h] package */						   
