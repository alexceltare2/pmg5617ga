Index: linux-2.6.36/include/linux/mm.h
===================================================================
--- linux-2.6.36.orig/include/linux/mm.h	2010-10-21 04:30:22.000000000 +0800
+++ linux-2.6.36/include/linux/mm.h	2017-04-27 16:44:45.486689318 +0800
@@ -1394,6 +1394,9 @@
 #define FOLL_GET	0x04	/* do get_page on page */
 #define FOLL_DUMP	0x08	/* give error on hole if it would be zero */
 #define FOLL_FORCE	0x10	/* get_user_pages read/write w/o permission */
+#if 1 //CVE-2016-5195 dirty COW
+#define FOLL_COW    0x4000  /* internal GUP flag */
+#endif
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
Index: linux-2.6.36/mm/memory.c
===================================================================
--- linux-2.6.36.orig/mm/memory.c	2010-10-21 04:30:22.000000000 +0800
+++ linux-2.6.36/mm/memory.c	2017-04-27 16:44:45.506699318 +0800
@@ -1225,6 +1225,27 @@
 }
 EXPORT_SYMBOL_GPL(zap_vma_ptes);
 
+#if 1 //CVE-2016-5195 dirty COW
+static inline bool can_follow_write_pte(pte_t pte, struct page *page,
+                    unsigned int flags)
+{
+    if (pte_write(pte))
+        return true;
+
+	/*   
+	* Make sure that we are really following CoWed page. We do not really
+	* have to care about exclusiveness of the page because we only want
+	* to ensure that once COWed page hasn't disappeared in the meantime
+	* or it hasn't been merged to a KSM page.
+	*/
+    if ((flags & FOLL_FORCE) && (flags & FOLL_COW))
+        return page && PageAnon(page) && !PageKsm(page);
+
+    return false;
+}
+#endif
+
+
 /**
  * follow_page - look up a page descriptor from a user-virtual address
  * @vma: vm_area_struct mapping @address
@@ -1286,10 +1307,19 @@
 	pte = *ptep;
 	if (!pte_present(pte))
 		goto no_page;
+#if 0 //CVE-2016-5195 dirty COW
 	if ((flags & FOLL_WRITE) && !pte_write(pte))
 		goto unlock;
+#endif
 
 	page = vm_normal_page(vma, address, pte);
+#if 1 //CVE-2016-5195 dirty COW
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, page, flags)) {
+		pte_unmap_unlock(ptep, ptl);
+		return NULL;
+	}
+#endif
+
 	if (unlikely(!page)) {
 		if ((flags & FOLL_DUMP) ||
 		    !is_zero_pfn(pte_pfn(pte)))
@@ -1310,7 +1340,9 @@
 		 */
 		mark_page_accessed(page);
 	}
+#if 0 //CVE-2016-5195 dirty COW
 unlock:
+#endif
 	pte_unmap_unlock(ptep, ptl);
 out:
 	return page;
@@ -1463,17 +1495,17 @@
 				 * The VM_FAULT_WRITE bit tells us that
 				 * do_wp_page has broken COW when necessary,
 				 * even if maybe_mkwrite decided not to set
-				 * pte_write. We can thus safely do subsequent
-				 * page lookups as if they were reads. But only
-				 * do so when looping for pte_write is futile:
-				 * in some cases userspace may also be wanting
-				 * to write to the gotten user page, which a
-				 * read fault here might prevent (a readonly
-				 * page might get reCOWed by userspace write).
+				 * pte_write. We cannot simply drop FOLL_WRITE
+				 * here because the COWed page might be gone by
+				 * the time we do the subsequent page lookups.
 				 */
 				if ((ret & VM_FAULT_WRITE) &&
 				    !(vma->vm_flags & VM_WRITE))
+#if 1 //CVE-2016-5195 dirty COW
+					foll_flags |= FOLL_COW;
+#else
 					foll_flags &= ~FOLL_WRITE;
+#endif
 
 				cond_resched();
 			}
